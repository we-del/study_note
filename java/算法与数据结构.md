# 算法与数据结构

![image-20220319104033724](D:\typora_import_images\typora-user-images\image-20220319104033724.png)

## 技巧

+ 注意

  ```java
  /*
   1. 越界判断要在所有判断之前，否则为无效越界判断
  */
  ```

  

+ ```java
  /*
    1. 反转数组
      for (int j = arr.length-1,e=0; e <=j &&j!=e ; j--,e++) {
                      arr[j]^=arr[e];
                      arr[e]^=arr[j];
                      arr[j]^=arr[e];
                  }
   2. 在进行取值判断前，可以先进行是否越界判断，此时可以添加程序运行效率
   3. 一维数组可以表达两个行为 即 行 和 数值 ， 二维数组可以表达三个行为 即 行 ，列，数值
   
  */
  ```
  
+ 细节(递归)

  ```java
  /*
   1. 递归碰到 return 会立即返回 不会向下执行(返回到该行调用的语句，如果有返回值，则需要进行处理(如那一个变量来接收，最后把所有解一并返回 ||  在一行调用多个方法，此时可以拿到全部的解))
   2. 每次即将开始递归调用时，会在改行留下一个记录，待改递归调用完毕后，会回到该记录点继续执行
   
  */
   
   // 递归返回非void类型的解的实例
   public class AssociateNumber {
      public static void main(String[] args) {
          System.out.println(process("8111".toCharArray(), 0));
      }
  
      /**
       * 当 输入一串0-9的字符串后，判断其能有多少种字母的排列组合
       * 如   111    有 aaa  ak ka  3 种
       *
       * @description: 此方法用来获取该问题的解
       * @description:  关于递归的返回值的补充
       *              递归可以返回任何类型，但不能直接把返回值整个返回会去,这样只能得到一个解，如果想得到多个解可以定义一个变量接收，算完所有解后再把该变量返回即可
       			以下写法 随是两次递归调用但返回的是一个结果
       */
      public static int process(char[] c, int i) {
          if (i == c.length) { // 当一次方法全部组合完毕后，得到一个该问题的解
              return 1;
          }
          if (c[i] == '0') { // 当遇到0则得不到一个问题的解，因为被其阻拦
              return 0;
          }
          if (c[i] == '1') {
              int result = 0; // 处理 1 ~ 19
              result += process(c, i + 1);
              if(i+1<c.length){
                  result += process(c, i + 2);
              }
              return result;
          }
  
          if(c[i] == '2'){ // 处理 2~ 2n(n范围在 0~6)
              int res = 0;
              res += process(c, i + 1);
              if(i+1<c.length &&  c[i+1]>='0' && c[i+1]<='6'){
                  res+=process(c,i+2);
              }
              return res;
          }
          return process(c,i+1); // 3~9 的情况
      }
  }
      // 求路径解法  ，使用  在一行调用多个方法，此时可以拿到全部的解
        public static int process(int n, int cur, int rest, int p) {
          if (rest == 0) {
              return cur == p ? 1 : 0;
          }
          if (cur == 1) { // 当前来到 1 位置此时只能忘右走
              return process(n, cur + 1, rest - 1, p);
          }
          if (cur == n) {
              return process(n, cur - 1, rest, p);
          }
          return process(n, cur - 1, rest - 1, p) + process(n, cur + 1, rest - 1, p);
      }
  ```
  
  

程序 = 数据结构+算法

## 1.0 数据结构

+ 数据结构结构

  ```java
  /*
  数据结构包括 线性结构和非线性结构
  
  线性结构
  	线性结构是最常用的数据结构，其特点就是数据元素间存在一对一关系
  	线性结构有两种不同的存储结构：顺序存储结果和链式存储结构。顺序存储的线性表称为顺序表，顺序表存储的元素是连续的(数组就是顺序表)；链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
  	线性结构常见的有：数组，队列，链表和栈
  	
  非线性结构
  	非线性结构其特点为数据与元素间存在一对多的关系
  	非线性结构包括：二维数组，多维数组，广义表，树结构，图结构
  */
  ```


### 1.1 稀疏数组

```java
/*
稀疏数组(sparse array)
 当一个数组中大部分元素为0或为同一个值时，可以使用稀疏数组来保存该数组
 
 稀疏数组处理方法
 	记录数组一共有几行几列，有多少个不同的值
 	把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模
 	
 二维数组转稀疏数组的思路
 	遍历 原始的二维数组，得到有效数据的个数sum
 	根据sum创建稀疏数组 sparseArr int[sum+1][3],并在其0索引位置存储原始数组基本信息(行,列,有效值个数)
 	将二维数组有效数据个数存入稀疏数组
 	
 稀疏数组转二维数组思路
 	读取稀疏数组第一行，根据第一行的数据，创建原始的二维数组
 	在读取稀疏数组后几行的数据，并赋值给原始二维数组
 	
 使用
 	 public static void main(String[] args) {
        // 创建一个稀疏数组 ， 稀疏数组是一个二维数组存储着另一个二维数组的有效数据
        int row = 7;
        int col = 7;
        int[][] arr = new int[row][col];
        // 模拟数组中已有数据
        arr[3][4] = 12;
        arr[1][2] = 13;
        arr[4][1] = 7;
        arr[6][4] = -21;
        arr[1][6] = 54;
        arr[0][4] = 22;
        int count = 0; // 此属性用于记录有效的数据个数
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                if (arr[i][j] != 0) count++;
            }
        }

        int[][] sparseArray = new int[count + 1][3];
        // 初始化第一行的数据
        sparseArray[0][0] = row;
        sparseArray[0][1] = col;
        sparseArray[0][2] = count;
        count = 1;

        // 存储稀疏数据
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[i].length; j++) {
                if (arr[i][j] != 0) {
                    sparseArray[count][0] = i; // 存储行
                    sparseArray[count][1] = j; // 存储列
                    sparseArray[count][2] = arr[i][j]; // 存储值
                    count++;
                }
            }
        }


        // 查看稀疏数组的数据
        for (int[] ints : sparseArray) {
            for (int anInt : ints) {
                System.out.print(anInt + " ");
            }
            System.out.println();
        }

        // 将稀疏数组存储到磁盘中
        try {
            ObjectOutputStream objectOutputStream = new ObjectOutputStream(
                    new FileOutputStream("D:\\aLearning\\java\\data_structure_code\\com\\sparseArray.data"));
            objectOutputStream.writeObject(sparseArray); // 将稀疏数组以对象保存
        } catch (IOException e) {
            e.printStackTrace();
        }


        // ============================ 稀疏数组 ----> 原始二维数组
        // 读取磁盘中的稀疏数组
        int[][] sparseArr = null;
        try {
            ObjectInputStream objectInputStream = new ObjectInputStream(
                    new FileInputStream("D:\\aLearning\\java\\data_structure_code\\com\\sparseArray.data"));
            sparseArr = (int[][]) objectInputStream.readObject(); // 将对象反序列化为稀疏数组
        } catch (Exception e) {
            e.printStackTrace();
        }
        // 将稀疏数组转换为二维数组
        int[][] arrFromSparseArr = new int[sparseArr[0][0]][sparseArr[0][1]];
        for (int i = 1; i < arrFromSparseArr.length; i++) {
            // 将稀疏数组存储的行列和值装载入arrFromSparseArr二维数组中
            arrFromSparseArr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        // 查看装载结果
        for (int i = 0; i < arrFromSparseArr.length; i++) {
            for (int j = 0; j < arrFromSparseArr[i].length; j++) {
                if (arrFromSparseArr[i][j] != 0) {
                    System.out.println("在" + i + "行" + j + "列有一个值为" + arrFromSparseArr[i][j]);

                }
            }
        }
    }
 	
 注意
 	稀疏数组一般会进行存盘保存(即保存到计算机中)
*/
```

下图左边为二维数组，右边为稀疏数组记录的值![image-20220207185631111](D:\typora_import_images\typora-user-images\image-20220207185631111.png)



### 1.2 队列

+ 队列(普通队列)

  ```java
  /*
   队列是一个有序列表，可以用数组(循序存储)或链表(链式存储)来实现。它遵循先进先出原则，即现存入队列的数据先取出，后存入队列的数据后取出
   
   数组实现队列思路
   	准备两个变量 int pre,next(初始值都为-1) 保存终点和起点位置
  	每当有一个数据添加到数组 next++,最终使next指向数组尾部
  	当从数组取出一个数据后时 pre++,使pre指向前一个点
  	当 pre == next表示没有可取出的数据 ，pre == arr.length - 1 表示已经存满
  	
   使用
      // 队列基本实现，此队列空间复用率低，需要使用环形队列来提高空间复用率
   	public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          String key = null;
          boolean loop = true;
          Queen queen = new Queen(3);
          while(loop){
              System.out.println("输入a(add)添加数据");
              System.out.println("输入g(getData)得到数据");
              System.out.println("输入s(show)得到当前指向");
              System.out.println("输入e(exit)退出");
              System.out.println("输入除了以上其他键重新选择");
              key = scanner.next();
              switch (key){
                  case "a":
                      // 添加随机数
                      queen.add((int)(Math.random()*10));
                      break;
                  case "g":
                      int data = queen.getData();
                      break;
                  case "s":
                      queen.showHead();
                      break;
                  case "e":
                      loop = false;
                      break;
                  default:
                      break;
              }
          }
      }
  
      static class Queen {
          private int pre; // 指向前一个节点
          private int next; // 指向后一个节点
          private int arr[];
  
          // 初始化队列
          public Queen(int size) {
              arr = new int[size];
              pre = -1;
              next = -1;
          }
  
          // 添加数据到队列
          public void add(int value) {
  
              if (pre == arr.length - 1) {
                  throw new RuntimeException("队列空间不足");
              }
              pre++;
              arr[pre] = value;
          }
          
          // 从队列取出数据
          public int getData(){
              if(pre == next){
                  throw new RuntimeException("没有可取出的数据");
              }
              next++;
              System.out.println("取出了"+next+"位置的数据，为："+arr[next]);
              return arr[next];
          }
  
          // 显示当前头数据
          public void showHead(){
              if(pre == next){
                  throw new RuntimeException("没有可取出的数据");
              }
              System.out.println("当前在"+(next+1)+"位置，数据为："+arr[next+1]);
          }
      }
  */
  ```

  队列示意图![image-20220208092706524](D:\typora_import_images\typora-user-images\image-20220208092706524.png)



+ 环形队列(需要加强)

  ```java
  /*
   环形队列实现思路
   	使 int pre(指向前一个元素) 和int next(指向后一个元素) 初始值为 0 
  	当队列满时，条件是 (next+1)%maxSize == pre
  	当队列空时，条件为 next == pre
  	队列中的有效数据个数为 (next+maxSize-pre)%maxSize
  	
   使用
   	  public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          String key = null;
          boolean loop = true;
          CircleQueen queen = new CircleQueen(4);
          while (loop) {
              System.out.println("输入a(add)添加数据");
              System.out.println("输入g(getData)得到数据");
              System.out.println("输入s(show)得到当前指向");
              System.out.println("输入all(showData)得到当前指向");
              System.out.println("输入e(exit)退出");
              System.out.println("输入除了以上其他键重新选择");
              key = scanner.next();
              switch (key) {
                  case "a":
                      // 添加随机数
                      queen.add((int) (Math.random() * 10));
                      break;
                  case "g":
                      int data = queen.getData();
                      break;
                  case "s":
                      queen.showHead();
                      break;
                  case "e":
                      loop = false;
                      break;
                  case "all":
                      queen.showData();
                  default:
                      break;
              }
          }
      }
  
      static class CircleQueen {
          private int maxSize;
          /**
           * 约定 front rear 初始值为 0 且留有一个预留空间
           */
          private int front; // 指向队列头
          private int rear; // 指向队列尾
          private int arr[];
  
          // 初始化队列
          public CircleQueen(int size) {
              arr = new int[size];
              maxSize = size;
          }
  
          // 添加数据到队列
          public void add(int value) {
  
              if (isFull()) {
                  System.out.println("队列空间不足");
                  return;
              }
              arr[rear] = value; // 直接添加数据
              rear = (rear + 1) % maxSize;
          }
  
          // 判断数据是否存满
          public boolean isFull() {
              /**
               * 此算法会留有一个预留空间 如 4个空间 第一次存储  1 2 3  (设front = 0)
               * 第二磁存储 0 2 3 （设front = 1）
               * 第三次存储 0 1 3(设 front = 2)
               * 第四次存储 0 1 2 (设 front = 3)
               * */
              return (rear + 1) % maxSize == front;
          }
  
          // 判断数据是否为空
          public boolean isEmpty() {
              return front == rear;
          }
  
          // 从队列取出数据
          public Integer getData() {
              if (isEmpty()) {
                  System.out.println("没有可取出的数据");
                  return null;
              }
              int value = arr[front];
              front = (front + 1) % maxSize;
              return value;
          }
  
          // 显示当前头数据
          public void showHead() {
              if (isEmpty()) {
                  System.out.println("没有可取出的数据");
                  return;
              }
              System.out.println("当前在" + front + "位置，数据为：" + arr[front]);
          }
  
          // 显示全部数据
          public void showData() {
              for (int i = front; i < front + size(); i++) {
                  System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i%maxSize]);
              }
          }
  
          // 求出当前队列有效数据个数
          public int size() {
              return (rear + maxSize - front) % maxSize;
          }
      }
  */
  ```


### 1.3 链表

+ 链表(单向)

  ```java
  /*
   链表是有序的列表。它以节点的方式来存储，每个节点包含一个data域(存储数据)，和next域(指向下一个节点地址)
  	
   完成链表删除和中间插入思路
   	使用两个临时变量 tmp,pre， 使 tmp = head.next ,pre = head ; 在他们完成一次查找后同时执行 tmp = tmp.next; pre = pre.next; 此时就能知道了tmp的前一个节点和后一个节点，可以方便的完成增删改操作
  	
   使用
   	 public static void main(String[] args) {
          HeroesNode h1 = new HeroesNode("张翼德", "张飞");
          HeroesNode h2 = new HeroesNode("刘备", "刘玄德");
          HeroesNode h3 = new HeroesNode("关羽", "关云长");
          HeroesNode h4 = new HeroesNode("诸葛亮", "孔明");
          HeroesNode h5 = new HeroesNode("庞统", "凤雏");
  
          SingleLinkedList singleLinkedList = new SingleLinkedList();
  
          // 添加节点
          singleLinkedList.init(h3); // 载入表头
          singleLinkedList.add(h5); // 向链表后方插入数据
          singleLinkedList.add(h2); // 向链表后方插入数据
          singleLinkedList.add(h2); // 向链表后方插入数据
          singleLinkedList.add(h4); // 向链表后方插入数据
          singleLinkedList.add(h1);
  
          // 展示链表中的数据
          singleLinkedList.list();
  
          // 更新节点
          singleLinkedList.updateNode(5,"士元");
  
          // 删除节点
          singleLinkedList.removeNode(3);
          singleLinkedList.list();
      }
  
  
      // 单向链表类
      static class SingleLinkedList {
          private HeroesNode head = new HeroesNode();
  
  
          // 向链表尾部添加数据(根据节点id排序)
          public void add(HeroesNode hero) {
              if (head.next == null) {
                  System.out.println("链表中还没有数据");
                  return;
              }
  
              // 查找此节点是否存在
              if (find(hero)) {
                  System.out.println("链表中以存在此节点");
  				return;
              }
  
              // 获得前后节点
              HeroesNode tmp = head.next;
              HeroesNode pre = head;
  
              while (true) {
                  // id插入
                  if (tmp.node_id > hero.node_id) {
  
                      // 如果添加节点比头部小 则替换头部节点
                      if (head.next.node_id == tmp.node_id) {
                          head.next = hero;
                      } else {
                          // 如果添加节点比中部节点小 则插入添加节点到中部节点前
                          pre.next = hero;
                      }
                      hero.next = tmp;
                      break;
                  }
  
  
                  // 尾部插入(id最大尾部插入)
                  if (tmp.next == null) {
                      tmp.next = hero;
                      break;
                  }
                  tmp = tmp.next;
                  pre = pre.next;
              }
          }
  
  
          // 查找链表中是否存在此节点
          public boolean find(HeroesNode hero) {
  
              // 如果链表中有相同数据则放弃存储
              HeroesNode tmp = head.next;
              while (true) {
                  if (tmp.node_id == hero.node_id) {
                      return true;
                  }
                  if (tmp.next == null) { // 遍历完都没有相同的节点
                      return false;
                  }
                  tmp = tmp.next;
              }
  
          }
  
          // 更新节点内容
          public void updateNode(int id, String content) {
  
              HeroesNode tmp = head.next;
              while (true) {
                  if (tmp.node_id == id) {
                      tmp.nickName = content;
                      System.out.println("完成节点更新");
                      return;
                  }
                  if (tmp.next == null) {
                      System.out.println("没有改节点");
                      return;
                  }
                  tmp = tmp.next;
              }
          }
  
          // 删除节点
          public void removeNode(int id) {
              HeroesNode pre = head;
              HeroesNode tmp = head.next;
              while (true) {
  
                  // 找到了节点
                  if (tmp.node_id == id) {
                      pre.next = tmp.next;
                      tmp.next = null;
                      System.out.println("节点删除成功");
                      return;
                  }
  
                  // 没有找到节点
                  if (tmp.next == null) {
                      System.out.println("该节点不存在");
                      return;
                  }
  
                  // 一直往后移动
                  pre = pre.next;
                  tmp = tmp.next;
              }
          }
  
          // 遍历链表的数据
          public void list() {
              if (head.next == null) {
                  System.out.println("此链表没有数据");
                  return;
              }
              HeroesNode tmp = head.next;
              while (true) {
                  if (tmp.next == null) {
                      System.out.println(tmp);
                      break;
                  }
                  System.out.println(tmp);
                  tmp = tmp.next;
              }
          }
  
          // 使表头指向一个链表
          public void init(HeroesNode hero) {
              head.next = hero;
          }
      }
  
      static class HeroesNode {
          static int num = 1;
          private int node_id = num;
          private String name;
          private String nickName;
          private HeroesNode next;
  
          {
              num++;
          }
  
          public HeroesNode(int node_id, String name, String nickName) {
              this.node_id = node_id;
              this.name = name;
              this.nickName = nickName;
          }
  
          public HeroesNode(String nickName, String name) {
              this.nickName = nickName;
              this.name = name;
          }
  
          public HeroesNode() {
          }
  
          @Override
          public String toString() {
              return "HeroesNode{" +
                      "node_id=" + node_id +
                      ", name='" + name + '\'' +
                      ", nickName='" + nickName +
                      '}';
          }
      }
  
   注意
   	链表各节点不一定是连续的
   	链表分为带头节点链表和不带头节点链表
   	head节点不存放具体数据，仅代表链表的头部
   	
   单链表测试题
   	求单链表中节点的个数 
   		思路：遍历拿个变量记录即可
   	查找单链表中倒数第k各节点
   		思路：准备一个方法，接收其传入的k值，然后遍历链表记录长度，最后记录长度-k的值，在重新遍历，判	   断长度-k 输出当前链表即可
   	单链表的反转
   		思路：在定义一个节点 reverseHead = new HeroesNode(),从头到尾遍历原来的链表，每遍历一个节点        将其取出，并放到新的李娜表reverseHead的最前端，最后使 head.next=reverseHead.next
   		实现
   			 // 链表反转
          public void reverseLinkedList() {
              // 判断head是否为空或链表是否只有一个节点
              if (head.next == null || head.next.next == null) {
                  return;
              }
              HeroesNode reverseHead = new HeroesNode(); // 反转头节点
              HeroesNode cur = head.next; // 指向第一个头节点
              HeroesNode next = null; // 辅助移动
  
              while(cur!=null){
                  next = cur.next; // 记录cur节点指向的下一个节点
                  cur.next = reverseHead.next; // 让最新的节点指向头节点
                  reverseHead.next = cur; // 让最新的节点变为头节点
                  cur = next; // 移动到下一个节点
              }
              head.next = reverseHead.next; //  改变head头节点指向
  
          }
   	从尾到头打印单链表
   		思路： 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出特点 实现逆序打印
   	合并两个有序单链表，合并后链表依然有序
   		实现
   		public void reversePrint(){
              if(head.next == null){
                  System.out.println("这只一个空链表");
                  return;
              }
              Stack<HeroesNode> heroesNodes = new Stack<>();
              HeroesNode cur = head.next;
              while(cur!=null){
                  heroesNodes.add(cur);
                  cur = cur.next;
              }
              while(heroesNodes.size()>0){
                  System.out.println(heroesNodes.pop());
              }
              
          }
      合并两个有序单链表，合并后链表仍然有序
      	思路：创建一个临时空链表，对比着两个链表的值，谁小就放到前面，最后head指向这个链表
  */
  ```
  
  单向链表![image-20220208140406454](D:\typora_import_images\typora-user-images\image-20220208140406454.png)
  
  ![image-20220208140916194](D:\typora_import_images\typora-user-images\image-20220208140916194.png)



+ 链表面试题解法

  ![image-20220321101144923](D:\typora_import_images\typora-user-images\image-20220321101144923.png)

  ![image-20220321101207836](D:\typora_import_images\typora-user-images\image-20220321101207836.png)

  

+ ![image-20220321112231713](D:\typora_import_images\typora-user-images\image-20220321112231713.png)

  ```java
  public class FastAndSlowPointer {
      public static void main(String[] args) {
          LinkedList linkedList = new LinkedList();
  
          for (int i = 0; i < 20; i++) {
              linkedList.add((int)(Math.random()*30)+1);
          }
          int size = linkedList.size();
          linkedList.list();
          System.out.println(size);
  
          // 得到上中点
          System.out.println("linkedList.getPivotNode(true) = " + linkedList.getPivotNode(true));
          System.out.println("linkedList.getPivotNode(false) = " + linkedList.getPivotNode(false));
          System.out.println("linkedList.getPivotPreNode(true) = " + linkedList.getPivotPreNode(true));
          System.out.println("linkedList.getPivotPreNode(false) = " + linkedList.getPivotPreNode(false));
      }
  
      private static class LinkedList {
          public Node head = new Node();
  
          public void add(int value) {
              Node node = new Node(value);
              if (head.next == null) {
                  head.next = node;
                  return;
              }
              head.add(node);
  
          }
  
          public int size() {
              return head.size();
          }
  
          public void list() {
              head.list();
          }
  
          // flag为true 且长度为偶数返回上中点，否则返回下中点
          public Node getPivotNode(boolean flag) {
              // 1 2 3 4 5
              int size = size();
              if (size % 2 == 1) {
                  return head.getAppointNode(size / 2 + 1);
              }
              if (flag) {
                  return head.getAppointNode(size / 2);
              } else {
                  return head.getAppointNode(size / 2 + 1);
              }
          }
  
  
          // flag为true 且长度为偶数返回上中点前一个，否则返回下中点前一个
          public Node getPivotPreNode(boolean flag) {
              int size = size();
              if (size % 2 == 1) {
                  return head.getAppointNode(size / 2);
              }
              if (flag) {
                  return head.getAppointNode(size / 2 - 1);
              } else {
                  return head.getAppointNode(size / 2 + 2);
              }
          }
      }
  
      private static class Node {
          public Node next;
          public int value;
  
          public Node(int value) {
              this.value = value;
          }
  
          public Node() {
          }
  
          public void add(Node node) {
              Node tmp = null;
  
              if (node.value < this.next.value) {
                  tmp = this.next;
                  this.next = node;
                  node.next = tmp;
                  return;
              }
              Node cur = this.next;
              tmp = this;
              while (true) {
  
                  // 找到链表中间插入点，进行插入
                  if (node.value < cur.value) {
                      tmp.next = node;
                      node.next = cur;
                      return;
                  }
                  // 如果是最后一个
                  if (cur.next == null) {
                      cur.next = node;
                      return;
                  }
                  tmp = tmp.next;
                  cur = cur.next;
              }
          }
  
          public int size() {
              int len = 0;
              Node cur = this;
              // 有3个节点  1 1 | 2 2 | 3 3|
              while (cur.next != null) {
                  len++;
                  cur = cur.next;
              }
              return len;
          }
  
          public void list() {
              Node cur = this;
              while (cur.next != null) {
                  cur = cur.next;
                  System.out.print(cur.value + " -> ");
              }
              System.out.println();
  
          }
  
          @Override
          public String toString() {
              return "Node{" +
                      "value=" + value +
                      '}';
          }
  
          public Node getAppointNode(int index) {
              int tmp = 0;
              Node cur = this;
              while (tmp != index) {
                  cur = cur.next;
                  tmp++;
              }
              return cur;
          }
  
      }
  }
  ```

  





+ 双向链表

  ```java
  /*
   单项链表的查找方向只能是一个方向(不能实现自我删除，要借助变量帮助删除)，而双向链表可以向前或向后查找(可以实现自我删除)
   	双向链表的遍历，添加，修改，删除思路
   		遍历
   			遍历和单向链表的遍历思路一致 ，只是双向链表可以向前向后查找
   		添加(默认添加到双向链表的最后)
   			先找到双向链表的最后一个节点(next为null)
   			temp.next = newHeroNode;
   			newHeroNode.pre = temp;
   		修改 
   			修改和单向链表的遍历思路一致
   		删除
   			因为是双向链表，因此，它可以实现自我删除某个节点
   			temp.pre.next = temp.next; // 让temp前一个节点的next指向temp的下一个节点
   			temp.next.pre = temp.pre; // 让temp下一个节点的pre指向temp前一个节点
   	
   	添加实现
   		// 添加实现
   	  public void add(HeroesNode hero) {
              if (head.next == null) {
                  System.out.println("链表中还没有数据");
                  return;
              }
  
              // 查找此节点是否存在
              if (find(hero)) {
                  System.out.println("链表中以存在此节点");
                  return;
              }
  
              // 获得前后节点
              HeroesNode tmp = head.next;
  
              while (true) {
                  // id插入
                  if (tmp.node_id > hero.node_id) {
  
                      // 如果添加节点比头部小 则替换头部节点
                      if (head.next.node_id == tmp.node_id) {
                          head.next = hero;
                      } else {
                          // 如果添加节点比中部节点小 则插入添加节点到中部节点前
                          tmp.pre.next = hero;
                          hero.pre = tmp.pre;
  
                      }
                      hero.next = tmp;
                      tmp.pre = hero;
                      break;
                  }
  
  
                  // 尾部插入(id最大尾部插入)
                  if (tmp.next == null) {
                      tmp.next = hero;
                      hero.pre = tmp;
                      break;
                  }
                  tmp = tmp.next;
              }
          }
   	
   	删除实现
   		// 删除节点
           // 删除节点
          public void removeNode(int id) {
              HeroesNode tmp = head.next;
              while (true) {
  
                  // 找到了节点
                  if (tmp.node_id == id) {
  
                      if(tmp.next == null){
                      // 删除的是最后一个节点
                          tmp.pre.next = null;
                          tmp.pre = null;
                      } else if(tmp==head.next){
                          // 删除的是第一个节点
                          head.next = tmp.next;
                          tmp.next = null;
                      } else{
                          // 删除的是中点的节点
                          tmp.pre.next = tmp.next;
                          tmp.next.pre = tmp.pre;
                          tmp.next = null;
                          tmp.pre = null;
                      }
  
                      System.out.println("节点删除成功");
                      return;
  
                  }
  
                  // 没有找到节点
                  if (tmp.next == null) {
                      System.out.println("该节点不存在");
                      return;
                  }
  
                  // 一直往后移动
                  tmp = tmp.next;
              }
          }
  */
  ```

  ![image-20220209143446834](D:\typora_import_images\typora-user-images\image-20220209143446834.png)



+ 单项环形链表

  ```java
  /*
  单项环形链表指 多个链表间顺序指向，形成一个闭环
  构建单项环形链表思路
  	先创建第一个节点，让first指向改节点，并形成环形
  	当创建了一个新节点时，就把改节点加入到已有的环形来年表中
  遍历环形链表
  	让一个辅助指针cur，指向first节点
  	然后通过一个while循环遍历改环形链表即可(当 cur.next == first即为结束)
  	
  实现约瑟夫环(JosephCircle)
  		
  	 public static void main(String[] args) {
          CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
          circleSingleLinkedList.addBoy(10); // 添加10个节点
          circleSingleLinkedList.list(); // 列出环形列表所有的节点
          circleSingleLinkedList.countBoy();
      }
  
      static class CircleSingleLinkedList {
          private Boy head = new Boy(); // 头部指针
          private int length; // 获得链表长度
  
          // 创建环形
          public void addBoy(int nums) {
              length = nums;
              if (nums < 1) {
                  System.out.println("人数错误，请重新设置");
              }
              Boy cur = null;
              for (int i = 1; i <= nums; i++) {
                  Boy friend = new Boy(i, MyUtil.getRandomName());
                  if (i == 1) {
                      head.next = friend; // 记录头部节点
                      friend.next = friend; // 头部自己指向自己
                  } else {
                      cur.next = friend; // 使前一个节点指向后一个节点
                      if (i == nums) { // 生成的最后一个节点，形成一个环形
                          friend.next = head.next;
                      }
                  }
  
                  cur = friend;  // 记录上一个节点的地址
  
              }
          }
  
  
          // 遍历环形链表
          public void list() {
              if (head.next == null) {
                  System.out.println("当前链表没有数据");
                  return;
              }
              Boy tmp = head.next; // 指向环形链表第一个节点
              while (true) {
                  // 先打印节点 在判断该节点是否指向头节点，如果指向则停止遍历
                  System.out.println(tmp);
                  if (tmp.next == head.next) {
                      return;
                  }
                  tmp = tmp.next;
              }
          }
  
          // 解决约瑟夫环问题
          public void countBoy() {
              System.out.print("JosephCircle:");
              while (length > 0) {
                  // 随机出局 编号
                  int index = ((int) (Math.random() * length)) + 1;
  
                  // 设置前后指针
                  Boy cur = head.next; // 指向第一个
                  Boy pre = head.next;
                  while (true) {
                      pre = pre.getNext(); // 移动到环形链表末尾
                      if (pre.next == head.next) {
                          break;
                      }
                  }
  
                  for (int i = 1; i <= length; i++) {
                      if (index == 1) {
                          // 出局的是第一个
                          System.out.print(cur.getId() + "\t");
                          head.next = cur.next; // 将第二个当作表头
                          pre.setNext(cur.next); // 最后一个连接第二个
                          cur.next = null; //  第一个置空 , 等待被垃圾回收
                          break;
  
                      } else if (i == index) {
                          // 出局的是中点的一个或最后一个(逻辑一致)
                          System.out.print(cur.getId() + "\t");
                          pre.next = cur.next;
                          cur.next = null;
                          break;
                      }
  
                      // 没有出局 指针跟随移动
                      cur =cur.getNext();
                      pre = pre.getNext();
                  }
                  length--; // 出局一个length减一个
              }
          }
      }
  
      static class Boy {
          private int id;
          private String name;
          private Boy next;
  
          public int getId() {
              return id;
          }
  
          public Boy(int id, String name) {
              this.id = id;
              this.name = name;
          }
  
          public void setId(int id) {
              this.id = id;
          }
  
          public String getName() {
              return name;
          }
  
          public void setName(String name) {
              this.name = name;
          }
  
          public Boy getNext() {
              return next;
          }
  
          public void setNext(Boy next) {
              this.next = next;
          }
  
          public Boy() {
          }
  
          @Override
          public String toString() {
              return "Boy{" +
                      "id=" + id +
                      ", name='" + name + '\'' +
                      '}';
          }
      }
      
   注意
   	一个节点也可以形成单项环形链表，即自己指向自己
  */
  ```
  
  下图为单项环形链表
  
  ![image-20220209145424107](D:\typora_import_images\typora-user-images\image-20220209145424107.png)



### 1.4 栈

+ 栈(stack)

  ```java
  /*
   栈是一个先入后出的有序列表，是限制线性表中元素插入和删除只能在线性表的同一端进行的一种特殊线性表。运行插入和删除的一端未栈顶(Top)，固定的一端未栈底(bottom) . 
   由上可知，栈中元素最先放进去的最后取出，最后放进去的最先取出
   
   栈应用场景
   	子程序调用，处理递归调用，表达式转换(中缀表达式转换未后缀表达式)，二叉树遍历，图标的深度优先搜素法
   	
   实现栈的思路
   	使用数组来模拟栈
   	定义一个top表示栈顶，初始化未-1
   	入栈的操作，当有数据加入栈时，top++;stack[top] =data;
   	出战的操作，int value = stack[top];top--;return value;
   
   
   使用数组制作一个简易栈结构
    public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          String key = "";
          boolean loop = true;
  
          StackArray stackArray = new StackArray(3);
          while (true) {
              System.out.println("=========================");
              System.out.println("1. 添加数据到栈");
              System.out.println("2. 取出栈顶的一个数据");
              System.out.println("3. 列出栈里的数据");
              System.out.println("9. 退出");
              key = scanner.next();
              switch (key) {
                  case "1":
                      stackArray.push((int) (Math.random() * 8));
                      break;
                  case "2":
                      stackArray.pop();
                      break;
                  case "3":
                      stackArray.list();
                      break;
                  case "9":
                      loop = false;
                      break;
              }
          }
      }
   	class StackArray {
      private int maxSize;
      private int top = -1;
      private int[] arr;
  
      public StackArray(int maxSize) {
          if (maxSize <= 0) {
              throw new RuntimeException("请输入正确的初始值(>0)");
          }
          this.maxSize = maxSize;
          arr = new int[maxSize];
      }
  
      // 往自制栈里添加数据
      public void push(int value) {
          if (isFull()) {
              System.out.println("数组已经满了");
              return;
          }
          arr[++top] = value;
      }
  
      public boolean isFull() {
          return top + 1 == maxSize;
      }
  
      // 取出自制栈顶层的一个数据
      public Integer pop() {
          if (isEmpty()) {
              System.out.println("数组是空的");
              return null;
          }
          return arr[top--];
      }
  
      public boolean isEmpty() {
          return arr.length == 0 || top == -1;
      }
  
      public void list() {
          if (isEmpty()) {
              System.out.println("数组是空的");
              return;
          }
          for (int i = top; i >= 0; i--) {
              System.out.println(arr[i]);
          }
      }
  }
  
  
  
  使用链表(双向)构建一个简易栈结构
  	class StackLinkedList {
      private Date head = new Date();
      private Date last = new Date();
  
      // 初始化链表
      public void init(Date h) {
          head.setNext(h);
          last.setNext(h);
      }
  
      // 向栈压入数据
      public void push(Date h) {
          
          
          if(head.getNext()==null && last.getNext() == null){
              // 如果链表没有数据则新增数据压入栈底    
              head.setNext(h);
              last.setNext(h);
          }else{
              // 新增数据压入栈顶
              last.getNext().setNext(h); // 使当前指向的链表指向最新的链表
              h.setPre(last.getNext()); // 使最新链表的pre指向上一个链表
              last.setNext(last.getNext().getNext()); // 移动到最新的链表上
          }
      }
  
      // 取出栈顶的数据
      public Integer pop() {
          if (isEmpty()) {
              System.out.println("当前栈没有数据");
              return null;
          }
          int value = 0;
          if (head.getNext() !=null &&head.getNext().getNext()!=null) {
              // 栈里有二个或两个以上数据
              value = last.getNext().getValue();
              Date next = last.getNext();
              last.setNext(last.getNext().getPre());
              next.setPre(null); // 断掉和前一个链表的指向 pre = null
              last.getNext().setNext(null); // 断掉和最后一个链表的指向 next = null
          } else {
              // 栈里只有一个数据
              value = last.getNext().getValue();
              last.setNext(null);
              head.setNext(null);
          }
  
          return value;
      }
  
      // 遍历栈的全部数据
      public void list() {
          if (isEmpty()) {
              System.out.println("当前栈没有数据");
              return;
          }
          // first 在首部  last 在尾部  ，获得last节点，开始向first打印，即可完成栈结构
          Date tmp = last.getNext();
          while (true) {
              System.out.println(tmp);
              if (tmp.getPre() == null) {
                  return;
              }
              tmp = tmp.getPre();
  
          }
  
      }
  
      public boolean isEmpty() {
          return head.getNext() == null || last.getNext() == null;
      }
  }
  
  class Date {
      private Date pre;
      private Date next;
      private int value;
  
      public Date() {
      }
  
      @Override
      public String toString() {
          return "Date{" +
                  "value=" + value +
                  '}';
      }
  
      public Date(int value) {
          this.value = value;
      }
  
      public Date getPre() {
          return pre;
      }
  
      public void setPre(Date pre) {
          this.pre = pre;
      }
  
      public Date getNext() {
          return next;
      }
  
      public void setNext(Date next) {
          this.next = next;
      }
  
      public int getValue() {
          return value;
      }
  
      public void setValue(int value) {
          this.value = value;
      }
  }
  
  */
  ```

  ![image-20220210111232015](D:\typora_import_images\typora-user-images\image-20220210111232015.png)

###  1.5 表达式

+ 前缀表达式(波兰表达式)

  ```java
  /*
   前缀表达式的运算符位于操作数之前 如 (3+4)*5-6 的前缀表达式为 - * + 3 4 5 6
   前缀表达式求值过程
   	从右到左扫描表达式，遇到数字时，将数字压入栈底，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应的计算，并将结果入栈。重复上述操作直到表达式到最左端
   	
   注意
   	前缀表达式在做时，是栈顶的数减去其下的一个数
  */
  ```

  ![image-20220210205055936](D:\typora_import_images\typora-user-images\image-20220210205055936.png)



+ 中缀表达式

  ```java
  /*
   中缀表达式是常见的运算表达式，如(3+4)*5-6
   中缀表达式是人类最熟悉的，但计算机并部熟悉，因此需要进行转换(前缀或后缀)，多为后缀表达式
  */
  ```

  

+ 后缀表达式(逆波兰表达式)

  ```java
  /*
   后缀表达式又称 逆波兰表达式 域前缀表达式相似，只是运算符位于操作数之后
   	如 (3+4)*5-6 的后缀表达式为 3 4 + 5 * 6 -
   后缀表达式求值过程
   	从左到右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对他们做相应计算，并将结果入栈。重复上述过程直到表达式达到最右端
   
   注意
   	后缀表达式在做运算时，是栈顶下的一个数 减去 栈顶 的数
  */
  ```

  ![image-20220210205602492](D:\typora_import_images\typora-user-images\image-20220210205602492.png)

  ![image-20220210205940933](D:\typora_import_images\typora-user-images\image-20220210205940933.png)



+ 中缀表达式转后缀表达式

  ```java
  /*
   中缀表达式转后缀表达式思路
   	1）从左向右遍历字符串 
   	2）如果是 数字(包括连续) 就直接入 数栈
      3）如果是运算符 则 进行判断
      	1. 如果栈底为空 且 当前字符不是 ) 则直接存入符号栈底(当前字符不是 ) 是为了过滤开头就右()的情况)
      	2. 如果当前字符是 ( 直接入符号栈顶
      	3. 如果栈顶为 ( 且当前字符不是) 则直接将当前运算符存入符号栈顶(当前字符与不是) 是为了过滤 ((3))的情况)
      	4. 当碰到 ) ，则依次弹出符号栈顶的运算符到 数栈，直到碰到 ( 位置，此时丢弃()号
      	5. 如果当前运算符优先级 小于等于 符号栈顶的优先级 则将栈顶的运算符压入数栈，当前运算符压入栈顶 	     ，否则就将其压入栈顶
      4）重复遍历字符串直到达到表达式尾
      5）将符号栈中剩余的运算符依次淡出并压入数栈
      6） 将数栈所有的元素取出，存入集合反转在转为字符串即为后缀表达式
   
   中缀表达式转后缀表达式
   	中缀：5+2*(3+4*5-3)+(20*3)  |  后缀：5 2 3 4 5 * 3 - + * 20 3 * + +   
      
   使用
   
  */
   	 // 中缀表达式转后缀表达式(新)
      public static String invertToRearExpr(String express) {
          /**
           *   中缀表达式转后缀表达式思路
           *  	1）从左向右遍历字符串
           *  	2）如果是 数字(包括连续) 就直接入 数栈
           *     3）如果是运算符 则 进行判断
           *     	1. 如果栈底为空 且 当前字符不是 ) 则直接存入符号栈底(当前字符不是 ) 是为了过滤开头就右()的情况)
           *     	2. 如果栈顶为 ( 则直接将当前运算符存入符号栈顶
           *     	3. 当碰到 ) ，则依次弹出符号栈顶的运算符到 数栈，直到碰到 ( 位置，此时丢弃()号
           *     	4. 如果当前运算符优先级 小于等于 符号栈顶的优先级 则将栈顶的运算符压入数栈，当前运算符压入栈顶，否则就将其压入栈顶
           *     4）重复遍历字符串直到达到表达式尾
           *     5）将符号栈中剩余的运算符依次淡出并压入数栈
           *     6） 将数栈所有的元素取出，存入集合反转在转为字符串即为后缀表达式
           *
           * */
  
  
          // 首先准备两个栈 ，一个存储运算符，一个存储运算数
          Stack<String> signs = new Stack<>();
          Stack<String> nums = new Stack<>();
  
          int index = 0; // 字符串索引
          // 11+(32*2+12)-32/4
          while (true) {
              String c = express.charAt(index) + "";
              if (isOpe(c)) {
                  // 是操作符
  
                  // 过滤掉 peek()到没有的数据 防止报错
                  try {
                      if (priority(c) <= priority(signs.peek())) {
                          // 如果当前运算符优先级小于栈顶的优先级
                          nums.add(signs.pop());
                      }
                          signs.add(c);
                  } catch (Exception e) {
  
                  }
  
                  // 如果以(开头则直接存储
                  try {
                      if (c.equals("(")) {
                          signs.add(c); // 把 (压入栈中
                      } else if (signs.peek().equals("(") && !(c.equals(")"))) {
                          // !(c.equals(")")) 是为了过滤掉连续 ((3))括号的情况
                          // 说明该符号是(第一个字符直接压入
                          signs.add(c);
                      }
                  } catch (Exception e) {
                  }
  
                  if (c.equals(")")) {
                      // 说明改组 () 操作完成，取出改()中运算优先级最低的数据
                      while (true) {
                          if (!(signs.peek().equals("("))) {
                              nums.add(signs.pop());
                          } else {
                              signs.pop(); // 把 (丢出
                              break;
                          }
                      }
  
                      // 以) 结尾
                      if (index + 1 == express.length()) {
  
                          // 以 ) 结尾 需要弹出 符号栈的剩余符号
                          while (signs.size() != 0) {
                              nums.add(signs.pop());
                          }
                          return getRearExpr(nums, nums.size());
                      }
                  }
                  if (signs.empty() && !(c.equals(")"))) {
                      // 栈底为空直接压入
                      signs.add(c);
                  }
  
  
                  index++; // 前移辅助指针
  
  
              } else {
                  // 是数字
                  String numsStr = c;
  
                  // 连续读取数字字符，是符号字符就退出
                  while (true) {
                      // 判断express下一位是否为数字，是就截取，不是就退出
                      index++;
                      // 以 数字结尾
  
                      // 已经达到字符串末尾
                      if (index == express.length()) {
                          nums.add(numsStr);  //  将数字压入数栈
                          while (signs.size() != 0) {
                              nums.add(signs.pop());
                          }
                          return getRearExpr(nums, nums.size());
                      }
                      String c1 = express.charAt(index) + "";
                      if (!(isOpe(c1))) {
                          // 下一位是数字就读取，截取到字符串中
                          numsStr += c1;
                      } else {
                          // 下一位是操作符就退出
                          break;
                      }
  
                  }
  
  
                  // 将数字添加到栈中
                  nums.add(numsStr);
              }
          }
  
      }
  ```
  
  

### 1.6 递归

+ 递归可以模拟一颗树结构调用

+ 概念

  ```java
  /*
   递归指方法自己调用自己，每次调用时传入不同的变量，递归有助于编程者解决复杂的问题，同时可以使代码变得简洁
   
   递归调用规则
   	当程序执行到一个方法时，会开辟一个独立的空间(栈)
   	每个空间数据(局部变量)互相独立
   
   递归需要遵守的重要规则
   	执行一个方法时，就创建一个新的受保护的独立空间(栈空间)
   	方法的局部变量时独立的，不会互相影响
   	递归必须向退出递归的条件逼近，否则就是无限递归， (死归了)
   	当一个方法执行完毕，或遇到return是就会返回，遵守谁调用方法(哪一行)，该方法的返回值就返回给谁。同时当方法执行完毕或返回时，该方法就执行完毕了
   	
   注意
   	重复的事情可以用递归来解决(所以 循环和 递归之间是可以相互转换的)
   	每有一次循环就会额外开辟一条递归链
  */
  ```

  ![image-20220212150449518](D:\typora_import_images\typora-user-images\image-20220212150449518.png)



+ 八皇后(递归)

  ```java
  /*
   public class Queen8 {
      int max = 8;
      int[] array = new int[max];
  
      public static void main(String[] args) {
              new Queen8().check(0);
      }
  
      private void check(int n){
  
          // 已经找到结果
          if(n == max){
              print();
              return;
          }
          // check 每一次判读判断体哦见后就会递归进入到check中都有 for(int i =0; i<max;i++)的回溯，直到for循环结束为止。当一个分支不满足判断条件时该分支也就停止了，只有满足条件的分支才会被输出
          for(int i =0; i<max;i++){
              array[n] = i;
              if(judge(n)){
                  check(n+1);
              }
  
              // 如果冲突，则继续执行 array[n] = i; 极限该行的位移
          }
      }
  
      private void print(){
          for(int i =0; i< array.length;i++){
              System.out.print(array[i]+" ");
          }
          System.out.println();
      }
  
      // 判断是否在同一行或同一斜线
      private boolean judge(int n) {
          for (int i = 0; i < n; i++) {
              //  array[i] == array[n] 表示为 同 列
              //  Math.abs(n - i) == Math.abs(array[n] - array[i]) 表示为同一斜线   1-0 == 1-0   1: 0   2:1
              if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                  return false;
              }
          }
          return true;
      }
  }
  */
  ```

  ![image-20220213110057942](D:\typora_import_images\typora-user-images\image-20220213110057942.png)



+ 题目

  ![image-20220321115440084](D:\typora_import_images\typora-user-images\image-20220321115440084.png)

  该折痕符合下图规律，此时可以使用递归解决，**递归可以模拟一颗满二叉树的调用**

  ![image-20220321115502549](D:\typora_import_images\typora-user-images\image-20220321115502549.png)

  ```java
  public class PaperFold {
      public static void main(String[] args) {
          process(4);
      }
  
      /**
       *  折痕 可以看成一颗满二叉树 ， 递归模拟的二叉树也可以完成前序中序后序遍历
       * */
      public static void fold(int n, int N, boolean down) {
          if (n >= N) return;
  
          System.out.print(down ? "凹 " : "凸 ");
          fold(n + 1, N, true);
          fold(n + 1, N, false);
      }
  
      // 对该方法在进行封装，外部只有传入简单的参数即可完成调用
      public static void process(int N) {
          fold(1, N, true);
      }
  }
  ```

  

  

  



### 1.7 哈希表

哈希表实际上就是一个缓存层，但功能没有redis强大

+ 哈希表(散列)

  ```java
  /*
   散列表(哈希表) 根据关键码值而直接进行访问的数据结构。它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做 散列函数，存放记录的数组叫做 散列表(哈希表)
   哈希表实际上就是一个数组，数组里的元素指向一条链表
   
   实现(哈希表)
   
   	public class HashTable {
      private int size;
      private EmpLinkedList[] arr;
  
      public static void main(String[] args) {
          Scanner scanner = new Scanner(System.in);
          HashTable hashTable = new HashTable(8);
          int count = 0;
          String key = null;
          boolean loop = true;
          while (loop) {
  
              System.out.println("================================");
              System.out.println("add 添加员工");
              System.out.println("find 查找员工");
              System.out.println("list 列出员工");
              System.out.println("remove 删除员工");
              System.out.println("quit 退出");
              key = scanner.next();
              switch (key) {
                  case "add":
                      String name = MyUtil.getRandomName();
                      hashTable.add(new Emp(count++,name));
                      System.out.println(name + "添加成功");
                      break;
                  case "find":
                      System.out.println("请输入查找的编码(数字)");
                      int n = Integer.parseInt(scanner.next());
  
                      Emp emp = hashTable.find(n);
                      if (emp != null) {
                          System.out.println("成员：" + emp.name + " 在链表中");
                      } else {
                          System.out.println("输入的成员不存在");
                      }
                      break;
                  case "list":
                      hashTable.list();
                      break;
                  case "remove":
                      System.out.println("请输入删除的编码(数字)");
                      int no = Integer.parseInt(scanner.next());
                      Emp emp1 = hashTable.remove(no);
                      if (emp1 != null) {
                          System.out.println("成员：" + emp1.name + " 已经被删除");
                      } else {
                          System.out.println("输入的成员不存在");
                      }
                      break;
                  case "quit":
                      System.out.println("正在退出...");
                      try {
                          Thread.sleep(((int) (Math.random() * 300)) + 400);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
                      System.out.println("退出完成");
                      loop = false;
                      break;
              }
          }
      }
  
      public HashTable(int size) {
          this.size = size;
          arr = new EmpLinkedList[size];
  
          // 给数组里每一个索引添加头指针
          for (int i = 0; i < arr.length; i++) {
              arr[i] = new EmpLinkedList();
          }
      }
  
      // 给对应的索引的列添加信息
      public void add(Emp emp) {
          int index = hash(emp.id);
          arr[index].add(emp);
      }
  
      // 列出哈希表
      public void list() {
          for (int i = 0; i < size; i++) {
              arr[i].list(i + 1);
          }
      }
  
      // 查找数据
      public Emp find(int id) {
          // 根据传入的id金国hash得到对应的链表
          int index = hash(id);
  
          // 在对应的链表里调用该方法进行查找
          return arr[index].find(id);
      }
  
      // 删除员工
      public Emp remove(int id) {
          int index = hash(id);
          return arr[index].remove(id);
      }
  
      // hash策略
      public int hash(int id) {
          return id % size;
      }
  }
  
  class Emp {
      public int id ;
      public String name;
      public Emp next;
  
  
      public Emp(int id,String name) {
          this.id = id;
          this.name = name;
      }
  
      public Emp() {
      }
  
      @Override
      public String toString() {
          return "  id=" + id + "  name='" + name+"'";
      }
  }
  
  class EmpLinkedList {
      public Emp head = new Emp();
  
      public void add(Emp emp) {
          if (head.next == null) { // 添加到开头
              head.next = emp;
          } else {
              // 添加到末尾
              Emp cur = head.next;
              while (cur.next != null) {
                  cur = cur.next;
              }
              cur.next = emp;
          }
  
  
      }
  
      // 列出当前链表的所有信息
      public void list(int no) {
          if (head.next == null) {
              System.out.println(no + "号链表为空");
              return;
          }
  
          System.out.print(no + "号链表信息为 ");
          Emp cur = head.next;
          while (true) {
              System.out.print("  => " + cur);
              if(cur.next ==null){
                  break;
              }
              cur = cur.next;
          }
          System.out.println();
  
      }
  
      // 查找元素
      public Emp find(int id) {
          if (head.next == null) {
              System.out.println("当前链表为空");
              return null;
          }
          Emp cur = head.next;
          while (true) {
              if (cur.id == id) {
                  return cur;
              }
              if (cur.next == null) {
                  return null;
              }
              cur = cur.next;
          }
      }
  
      // 删除元素
      public Emp remove(int id) {
          if (head.next == null) {
              System.out.println("当前链表为空");
              return null;
          }
          Emp cur = head.next;
          Emp temp = head;
          while (true) {
              // 需要删除在链表首部
              if (cur == head.next && cur.id == id) {
                  head.next = cur.next;
                  cur.next = null;
                  return cur;
              }
  
              // 需要删除元素在链表中部
              if (cur.next != null && cur.id == id) {
                  temp.next = cur.next;
                  cur.next = null;
                  return cur;
              }
  
              if (cur.next == null && cur.id == id) {
                  temp.next = null; // 将上一个链表断开
                  return cur;
              }
              if (cur.next == null) {
                  return null;
              }
              temp = temp.next;
              cur = cur.next;
          }
      }
  
   */
  ```
  
  ![image-20220219195517744](D:\typora_import_images\typora-user-images\image-20220219195517744.png)
  
  ![image-20220219195808907](D:\typora_import_images\typora-user-images\image-20220219195808907.png)
  
  ![image-20220220095443709](D:\typora_import_images\typora-user-images\image-20220220095443709.png)

### 1.8 树

## 练习题需要加强

树是一种数据结构，用于存储数据

+ 树引入

  ```java
  /*
   数组存储方式分析
   	优点
   		通过下标方式访问元素,速度快,对于有序数组,还可以使用二分查找(插值查找,fib查找)等方式提高检索速度
  	缺点
  		如果要检索具体值，或插入值会整体移动，效率较低
   
   链式存储方式分析
   	优点
   		在一定程度上对数组存储方式有优化(插入或删除数据时只需要将节点添加到链表或从链表移除)
   	缺点
   		在进行检索时，效率较低，如 检索某个值，需要从头节点开始遍历
   		
   树存储方式分析
   	能提高数据存储，读取效率，如利用 二叉排序树 即可以保证数据的检索速度，同时可以保证数据的插入，删除，修改速度
  */
  ```

  ![image-20220220141813658](D:\typora_import_images\typora-user-images\image-20220220141813658.png)

#### 二叉树

+ 二叉树(常用术语)

  ```java
  /*
   常用术语
   	节点(root)	
   		一个一个对象(下图中的圆圈)就可以看作是一个节点，有些人喜欢称这为节点对象
   	根节点
   		指一个树的顶级节点(其上没有其他节点)，如下图中的 A 节点
   	父节点
   		指一个主节点和它的从节点的关系，如下图 A 是 B,C 的父节点；B 是 D,E 的父节点
   	子节点
   		指一个从节点和它的主节点的关系，如下图 B 是 A 的子节点， C 是 A 的子节点，F 是 C 的子节点
   	叶子节点
   		指没有子节点的节点，如下图 E，F,G,H都是叶子节点
   	节点的权
   		指该节点的数值，如下图 假设 A 的值是 13，则他的节点的权 就是 13
   	路径
   		指从root节点找到该节点的路线，如下图 假设要找到D的值 ， 则路径为 A,B,D
   	层
   		指数的层级，root节点为1级，其子节点为2级... , 如下图 A 的层级为 1; B,C 的层级为2，D,E,F,G 的层		  级为3 ...
   	子树
   		指一个从节点和一个主节点的关系，如下图 D 可以是 E,A的子树；C 可以是 A 的子树
   	树的高度
   		指从根节点开始到底部的层数，如下图 该树的高度为4
   	森林
   	 	多课子树可以构成森林
   	 	
  
  */
  ```

  ![image-20220220142323185](D:\typora_import_images\typora-user-images\image-20220220142323185.png)

  

  

+ 二叉树的概念

  ```java
  /*
    二叉树的概念
   	树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树
   	二叉树的子节点分为左节点和右节点
   	如果该二叉树的所有叶子节点都在最后一层，并且节点总数= 2^n-1(n为树的高度)，则我们称为 满二叉树(即所有的    父节点都占满了)
   	如果该二叉树的所有叶子节点都在最后一层或倒数第二层，且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树
  */
  ```

  

  ![image-20220220144817565](D:\typora_import_images\typora-user-images\image-20220220144817565.png)

  ![image-20220220145102785](D:\typora_import_images\typora-user-images\image-20220220145102785.png)



+ 二叉树的遍历

  ```java
  /*
    二叉树遍历分为 前序，中序和后序 （前序，中序和后序指的是父节点的位置，前序指先遍历，中序指第二个遍历，后续指最后遍历;左子节点优先级 大于 右子节点）
    	前序指 先输出父节点，在遍历左子节点和右子节点
    	中序指 先便利左子树，在输出父节点，在遍历右子树
    	后序指 先便利左子树 在遍历右子树 最后输出父节点
    	
    实现
    public class BinaryTrueTraversal {
      public static void main(String[] args){
          int count = 0;
          HeroNode heroNode1 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode2 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode3 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode4 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode5 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode6 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode7 = new HeroNode(++count, MyUtil.getRandomName());
          BinaryTree binaryTree = new BinaryTree();
          binaryTree.setRoot(heroNode1);
          binaryTree.getRoot().setLeft(heroNode3);
          binaryTree.getRoot().setRight(heroNode5);
          binaryTree.getRoot().getLeft().setLeft(heroNode2);
          binaryTree.getRoot().getLeft().setRight(heroNode6);
          binaryTree.getRoot().getRight().setLeft(heroNode4);
          binaryTree.getRoot().getRight().setRight(heroNode7);
  
          System.out.print("前序遍历： ");
          binaryTree.preOrder();
          System.out.println();
          System.out.print("中序遍历： ");
          System.out.println();
          binaryTree.infixOrder();
          System.out.println();
          System.out.print("后序遍历： ");
          binaryTree.afterOrder();
      }
  }
  
  class BinaryTree{
      private HeroNode root;
  
      public void setRoot(HeroNode root) {
          this.root = root;
      }
  
      public HeroNode getRoot() {
          return root;
      }
      public void preOrder(){
          this.root.preOrder();
      }
      public void infixOrder(){
          this.root.infixOrder();
      }
      public void afterOrder(){
          this.root.afterOrder();
      }
  }
  class HeroNode{
      private int id;
      private String name;
      private HeroNode left;
      private HeroNode right;
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  '}';
      }
  
      public HeroNode(int id, String name) {
          this.id = id;
          this.name = name;
      }
  
      // 前序遍历
      public void preOrder(){
          System.out.print(this+" ");
          if(this.left!=null){
              this.left.preOrder();
          }
          if(this.right!=null){
              this.right.preOrder();
          }
      }
  
      // 中序遍历
      public void infixOrder(){
          if(this.left!=null){
              this.left.infixOrder();
          }
          System.out.print(this+" ");
          if(this.right!=null){
              this.right.infixOrder();
          }
      }
  
      // 后序遍历
      public void afterOrder(){
          if(this.left!=null){
              this.left.afterOrder();
          }
          if(this.right!=null){
              this.right.afterOrder();
          }
          System.out.print(this+" ");
      }
  
      public int getId() {
          return id;
      }
  
      public void setId(int id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public HeroNode getLeft() {
          return left;
      }
  
      public void setLeft(HeroNode left) {
          this.left = left;
      }
  
      public HeroNode getRight() {
          return right;
      }
  
      public void setRight(HeroNode right) {
          this.right = right;
      }
  }
  */
  ```

  ![image-20220220154146767](D:\typora_import_images\typora-user-images\image-20220220154146767.png)



+ 二叉树 前序，中序和后序查找

  ![image-20220221152824807](D:\typora_import_images\typora-user-images\image-20220221152824807.png)

  ```java
  /*
  思路
  	也和前面 前序，中序和后序思路一致，先遍历查找每一个节点，在对返回的数据做判断如果为null则不做处理，如果不为null则将其返回
   实现
  public class BinaryTrueTraversal {
      public static void main(String[] args) {
          int count = 0;
          HeroNode heroNode1 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode2 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode3 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode4 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode5 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode6 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode7 = new HeroNode(++count, MyUtil.getRandomName());
          BinaryTree binaryTree = new BinaryTree();
          binaryTree.setRoot(heroNode1);
          binaryTree.getRoot().setLeft(heroNode3);
          binaryTree.getRoot().setRight(heroNode5);
          binaryTree.getRoot().getLeft().setLeft(heroNode2);
          binaryTree.getRoot().getLeft().setRight(heroNode6);
          binaryTree.getRoot().getRight().setLeft(heroNode4);
          binaryTree.getRoot().getRight().setRight(heroNode7);
  
          HeroNode heroNode = binaryTree.preSearch(7);
          System.out.println(heroNode);
      }
  }
  
  class BinaryTree {
      private HeroNode root;
  
      public void setRoot(HeroNode root) {
          this.root = root;
      }
  
      public HeroNode getRoot() {
          return root;
      }
  
  
      public HeroNode preSearch(int n) {
          return root.preFind(n);
      }
  
      public HeroNode infixSearch(int n) {
          return root.infixFind(n);
      }
  
      public HeroNode afterSearch(int n) {
          return root.afterFind(n);
      }
  }
  
  class HeroNode {
      private int id;
      private String name;
      private HeroNode left;
      private HeroNode right;
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  '}';
      }
  
      public HeroNode(int id, String name) {
          this.id = id;
          this.name = name;
      }
  
      // 前序查找
      public HeroNode preFind(int id) {
          if (this.id == id) {
              return this;
          }
          HeroNode no = null;
          if (this.left != null) {
              no = this.left.preFind(id);
              if (no != null) {
  
                  return no;
              }
          }
          if (this.right != null) {
              no = this.right.preFind(id);
              if (no != null) {
                  return no;
              }
          }
          return null;
      }
  
  
      // 中序查找
      public HeroNode infixFind(int id) {
  
          HeroNode no = null;
          if (this.left != null) {
              no = this.left.preFind(id);
              if (no != null) {
  
                  return no;
              }
          }
  
          if (this.id == id) {
              return this;
          }
          if (this.right != null) {
              no = this.right.preFind(id);
              if (no != null) {
                  return no;
              }
          }
          return null;
      }
  
      // 后序查找
      public HeroNode afterFind(int id) {
          HeroNode no = null;
          if (this.left != null) {
              no = this.left.preFind(id);
              if (no != null) {
  
                  return no;
              }
          }
          if (this.right != null) {
              no = this.right.preFind(id);
              if (no != null) {
                  return no;
              }
          }
  
          if (this.id == id) {
              return this;
          }
          return null;
      }
  
      public int getId() {
          return id;
      }
  
      public void setId(int id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public HeroNode getLeft() {
          return left;
      }
  
      public void setLeft(HeroNode left) {
          this.left = left;
      }
  
      public HeroNode getRight() {
          return right;
      }
  
      public void setRight(HeroNode right) {
          this.right = right;
      }
  }
  
  
  */
  ```

  

+ 二叉树删除节点

  ![image-20220221165156093](D:\typora_import_images\typora-user-images\image-20220221165156093.png)

  ```java
  /*
   实现
   	public class BinaryTrueTraversal {
      public static void main(String[] args) {
          int count = 0;
          HeroNode heroNode1 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode2 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode3 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode4 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode5 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode6 = new HeroNode(++count, MyUtil.getRandomName());
          HeroNode heroNode7 = new HeroNode(++count, MyUtil.getRandomName());
          BinaryTree binaryTree = new BinaryTree();
          binaryTree.setRoot(heroNode1);
          binaryTree.getRoot().setLeft(heroNode3);
          binaryTree.getRoot().setRight(heroNode5);
          binaryTree.getRoot().getLeft().setLeft(heroNode2);
          binaryTree.getRoot().getLeft().setRight(heroNode6);
          binaryTree.getRoot().getRight().setLeft(heroNode4);
          binaryTree.getRoot().getRight().setRight(heroNode7);
  
          binaryTree.removeNode(3);
      }
  }
  
  class BinaryTree {
      private HeroNode root;
  
      public void setRoot(HeroNode root) {
          this.root = root;
      }
  
      public HeroNode getRoot() {
          return root;
      }
  
  
      // 删除节点
      public void removeNode(int id){
          if(root.getId() == id){
              root = null;
          }else{
              root.removeNode(id);
          }
      }
  }
  
  class HeroNode {
      private int id;
      private String name;
      private HeroNode left;
      private HeroNode right;
  
      @Override
      public String toString() {
          return "HeroNode{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  '}';
      }
  
      public HeroNode(int id, String name) {
          this.id = id;
          this.name = name;
      }
  
      // 删除节点
      public void removeNode(int id) {
  
          if(this.left != null && this.left.id == id){
              this.left = null;
              return;
          }
          if(this.right != null && this.right.id == id){
              this.right = null;
              return;
          }
  
          if(this.left!=null){
              this.left.removeNode(id);
          }
          if(this.right!=null){
              this.right.removeNode(id);
          }
  
  
  
      }
  
  
      public int getId() {
          return id;
      }
  
      public void setId(int id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public HeroNode getLeft() {
          return left;
      }
  
      public void setLeft(HeroNode left) {
          this.left = left;
      }
  
      public HeroNode getRight() {
          return right;
      }
  
      public void setRight(HeroNode right) {
          this.right = right;
      }
  }
  */
  ```



+ 顺序存储二叉树

  ```java
  /*
   从数据存储方法来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组
   定义
   	顺序存储二叉树指，在树转换为数组后，仍然可以对该树数组采取 前序，中序和后序遍历操作
   特点
   	顺序存储二叉树通常只考虑二叉树为完全二叉树的情况
   	第n个元素的左子节点为 2*n+1 (n为当前父节点的索引)，如下图 3 的索引为 2 则其左子节点为 2*2+1 == 5
   	第n个元素的右子节点为 2*n+2 (n为当前父节点的索引)，如下图 2 的索引为 1 则其左子节点为 2*1+1 == 3
   	第n个元素的父节点为 (n-1)/2 (n为当前子节点的索引)，如下图 7 的索引为 6 则其父节点为 (6-1)/2 == 2
   	
   实现(顺序存储二叉树的遍历)
   	public class OrderStoreTree {
      public static void main(String[] args) {
          int[] arr = {1, 2, 3, 4, 5, 6, 7};
          ArrBinaryTree arrBinaryTree = new ArrBinaryTree(arr);
          arrBinaryTree.preOrder();
          System.out.println();
          arrBinaryTree.infixOrder();
          System.out.println();
          arrBinaryTree.afterOrder();
          System.out.println();
      }
  }
  
  class ArrBinaryTree {
      private int[] arr;
  
      public ArrBinaryTree(int[] arr) {
          this.arr = arr;
      }
  
      // 重载方法，此时代码整洁
      public void preOrder() {
          preOrder(0);
      }
      public  void infixOrder(){
          infixOrder(0);
      }
      public void afterOrder(){
          afterOrder(0);
      }
      // 前序遍历
      public void preOrder(int index) {
          if (index < 0 && index >= arr.length) {
              System.out.println("请传入正确的索引");
              return;
          }
          System.out.print(arr[index] + " ");
  
          // 左遍历
          if (2 * index + 1 < arr.length) {
              preOrder(2 * index + 1);
          }
          if (2 * index + 2 < arr.length) {
              preOrder(2 * index + 2);
          }
      }
  
      // 中序遍历
      public void infixOrder(int index) {
          if (index < 0 && index >= arr.length) {
              System.out.println("请传入正确的索引");
              return;
          }
  
          // 左遍历
          if (2 * index + 1 < arr.length) {
              infixOrder(2 * index + 1);
          }
  
          System.out.print(arr[index] + " ");
  
          if (2 * index + 2 < arr.length) {
              infixOrder(2 * index + 2);
          }
      }
  
      // 后序遍历
      public void afterOrder(int index) {
          if (index < 0 && index >= arr.length) {
              System.out.println("请传入正确的索引");
              return;
          }
  
          // 左遍历
          if (2 * index + 1 < arr.length) {
              afterOrder(2 * index + 1);
          }
          if (2 * index + 2 < arr.length) {
              afterOrder(2 * index + 2);
          }
          
          System.out.print(arr[index] + " ");
  
      }
  }
  注意
  	java中 整数 \ 整数 结果还是为整数
  */
  ```

  ![image-20220221214030928](D:\typora_import_images\typora-user-images\image-20220221214030928.png)





+ 线索化二叉树

  ```java
  /*
   介绍
   	n个节点的二叉链表中含有n+1个空指针域，利用二叉链表中的空指针域，存放指向该节点在某个遍历次序下的前驱和后继节点的指针(这种附加的指针成为"线索")
   	这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree).根据线索性质不同，线索二叉树可分为 前序线索二叉树，中序线索二叉树 和 后序线索二叉树
   	
   二叉树线索化工作流程
   	在二叉树采用既定的方法遍历完成后，判断当前的节点(left,right)是否为空，如果为都为空，则使用left去指向该遍历后的前驱节点，使用right指向该遍历后的后继节点。如果不为空则不做更改 。如下图
   	
   实现
   	public class ThreadedBinaryTree {
      public static void main(String[] args){
          HeroNode2 jimmy = new HeroNode2(1, "jimmy");
          HeroNode2 merry = new HeroNode2(3, "merry");
          HeroNode2 len = new HeroNode2(8, "len");
          HeroNode2 mary = new HeroNode2(10, "mary");
          HeroNode2 wd = new HeroNode2(6, "wd");
          HeroNode2 ed = new HeroNode2(14, "ed");
          BinaryTree2 binaryTree2 = new BinaryTree2();
          binaryTree2.setRoot(jimmy);
          jimmy.setLeft(merry);
          jimmy.setRight(wd);
          merry.setLeft(len);
          merry.setRight(mary);
          wd.setLeft(ed);
          binaryTree2.threadNodes(); // 完成线索二叉树
          System.out.println(len.getLeft());
          System.out.println(len.getRight());
  
      }
  }
  
  class HeroNode2 {
      private int id;
      private String name;
      private HeroNode2 left;
      private HeroNode2 right;
  
      // 如果 leftType && rightType 为0 表示指向子树，为 1 表示指向前驱&&后继节点
      private int leftType;
      private int rightType;
  
      @Override
      public String toString() {
          return "HeroNode2{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
  
                  '}';
      }
  
      public HeroNode2(int id, String name) {
          this.id = id;
          this.name = name;
      }
  
      public int getLeftType() {
          return leftType;
      }
  
      public void setLeftType(int leftType) {
          this.leftType = leftType;
      }
  
      public int getRightType() {
          return rightType;
      }
  
      public void setRightType(int rightType) {
          this.rightType = rightType;
      }
  
      public int getId() {
          return id;
      }
  
      public void setId(int id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public HeroNode2 getLeft() {
          return left;
      }
  
      public void setLeft(HeroNode2 left) {
          this.left = left;
      }
  
      public HeroNode2 getRight() {
          return right;
      }
  
      public void setRight(HeroNode2 right) {
          this.right = right;
      }
  }
  
  class BinaryTree2 {
      private HeroNode2 root;
  
      // 为实现线索化，需要创建一个指向当前节点的前驱节点的辅助指针
      private HeroNode2 pre = null;
  
      public void setRoot(HeroNode2 root) {
          this.root = root;
      }
  
      public HeroNode2 getRoot() {
          return root;
      }
  
      public void threadNodes(){
          threadNodes(root);
      }
  
      // 线索化二叉树(中序遍历)
     public void threadNodes(HeroNode2 node){
          if(node == null){
              return;
          }
          threadNodes(node.getLeft());
          
          // 如果当前节点的下一个左节点为空，就让其左节点指向其前驱节点(第一次指向null)
          if(node.getLeft() == null){ // 使当前节点指向他的前驱节点
              node.setLeft(pre);
              node.setLeftType(1);
          }
  
  		// 如果 辅助指针指向节点的右节点为空，就让其指向后继节点(当前节点)
          if(pre !=null && pre.getRight() == null){
              pre.setRight(node); // 使辅助指针指向的节点的right指向后继节点
              pre.setRightType(1);
          }
  
          // 辅助节点记录当前节点(上一个节点)
          pre = node;
  
          threadNodes(node.getRight());
     }
      public void preOrder() {
          this.root.preOrder();
      }
  
      public void infixOrder() {
          this.root.infixOrder();
      }
  
      public void afterOrder() {
          this.root.afterOrder();
      }
  
  
  }
   
   注意
   	一个节点的前节点，称为前驱节点 
   	一个节点的后一个节点，称为后继节点
  */
  ```
  
  ![image-20220222145216529](D:\typora_import_images\typora-user-images\image-20220222145216529.png)

+ 线索二叉树的遍历

  ```java
  /*
  分析
   	因为线索化后，各个节点指向有变化，因此原来的遍历方式不能适用，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线性方式遍历，因此无需使用递归方式，这样提高了遍历的效率，遍历的次序应当和中序遍历保持一致
   
   实现
   	  // 中序遍历
   	  public void threadedList() {
          HeroNode2 node = root;
  
          while (node != null) {
  
              // 找到一个leftType为1的节点
              while (node.getLeftType() == 0) {
                  node = node.getLeft();
              }
              System.out.println(node); // 打印该节点
  
  
              // 每有一个叶子节点就打印依次
              while (node.getRightType() == 1) {
                  node = node.getRight();
                  System.out.println(node);
              }
              // 最后移动到非叶子节点上
              node = node.getRight();
  
          }
      }
  */
  ```
  
  

#### 哈夫曼树

+ 哈夫曼树

  ```java
  /*
   介绍
   	给定n个权值作为n个叶子节点，构造一颗二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(赫夫曼殊)
   	赫夫曼树是带权路径长度最短的树，权值较大的节点离根较近
   
   赫夫曼殊重要概念
   	路径和路径的长度
          路径指，一个节点达到目标节点的通路。
          路径的长度指，从一个节点达到目标节点要经过的节点个数
          若规定根节点的层数为1，则从根节点到第L层节点的路径长度为 L-1
      节点的权和带权路径长度
      	若将树节点赋给一个有着某种含义的数值，则这个数值称为该节点的权。
      	节点的带权路径长度为：从根节点到该节点之间的路径长度与该节点的权的乘积
   	树的带权路径长度
   		树的带权路径长度规定为所有叶子节点的带权路径长度之和，记为WPL,权值越大的节点立根结点越近的二叉树才是最优二叉树
   
   注意
   	wpl最小的就是赫夫曼树
  */
  ```

  ![image-20220225161229162](D:\typora_import_images\typora-user-images\image-20220225161229162.png)

  

+ 赫夫曼树创建

  ```java
  /*
   创建步骤
   	从小到大进行排序，将每一个数据看成一个节点，每个节点堪称一个最简单的二叉树
   	取出根节点权值最小的两颗二叉树，组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
   	再将这颗新的二叉树 ，以根节点的权值大小再次排序(从小到大)，不断重复 1-2-3-4的步骤，直到数列中所有的数据都被处理，就得到了一颗赫夫曼树
   	
   实现
   	public class HuffmanTree {
      public static void main(String[] args){
          int[] arr = {13,7,8,3,29,6,1};
          createHuffmanTree(arr);
      }
      // 创建赫夫曼树的方法
      public static void createHuffmanTree(int[] arr){
  
          // 创建一个集合进行存储node节点
          List<Node> nodes = new ArrayList<>();
          for (int value : arr) {
              nodes.add(new Node(value));
          }
  
          System.out.println(nodes);
  
          // 当nodes.size() 小于等于1时 结束，此时说明霍夫曼树创建完毕
          while(nodes.size()>1){
              // 当传入一个参数(集合)时，该集合必须实现Comparable方法,Collections会去调用该集合下的compareTo方法
              Collections.sort(nodes); // 每次完成树创建后重新排序
              Node left = nodes.get(0);
              Node right = nodes.get(1);
              Node parentNodes = new Node(left.value + right.value);
              parentNodes.left = left;
              parentNodes.right = right;
              nodes.remove(left);
              nodes.remove(right);
              nodes.add(parentNodes);
          }
          preBinaryTree(nodes.get(0));
  
      }
  
      // 前序遍历二叉树
      public static void preBinaryTree(Node node){
          if(node == null){
              return;
          }
          System.out.println(node.value);
          preBinaryTree(node.left);
          preBinaryTree(node.right);
      }
  }
  
  // 为了让Node  对象持续排序 Collections集合
  // 让Node 类 实现Comparable接口
  class Node implements Comparable<Node>{
      int value; // 节点的权
      Node left; // 左子节点
      Node right; // 右子节点
  
      public Node(int value) {
          this.value = value;
      }
  
      @Override
      public String toString() {
          return "Node{" +
                  "value=" + value +
                  '}';
      }
  
      @Override
      public int compareTo(Node o) {
          return this.value - o.value;
      }
  }
  */
  ```

  ![image-20220225170904610](D:\typora_import_images\typora-user-images\image-20220225170904610.png)

  ![image-20220225170913158](D:\typora_import_images\typora-user-images\image-20220225170913158.png)

  ![image-20220225170854426](D:\typora_import_images\typora-user-images\image-20220225170854426.png)



+ 赫夫曼编码

  ```java
  /*
   介绍
   	赫夫曼编码翻译为 哈夫曼编码，是一种编码方式，属于一种程序算法
  	赫夫曼编码是赫夫曼树在电讯通信中经典应用之一
  	赫夫曼编码广泛地用于数据文件压缩，其压缩率通常在20%-90%之间
  	赫夫曼码是可变子长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码
  */
  ```

  ![image-20220225200958506](D:\typora_import_images\typora-user-images\image-20220225200958506.png)

  ![image-20220225201412586](D:\typora_import_images\typora-user-images\image-20220225201412586.png)

  ![image-20220226102320693](D:\typora_import_images\typora-user-images\image-20220226102320693.png)



+ 赫夫曼编码实现

  ```java
  /*
   注意
   	赫夫曼编码是一个前缀编码，其编码的组合不会和其他编码产生碰撞
   	赫夫曼编码比定长编码和变长编码更优秀，存储空间小效率高
   	赫夫曼编码是无损压缩，即在解压后不会出现任何问题
   	赫夫曼树根据排序方法不同，可能不太一样 ，如 {1,2,2,2,2,2,2,3,3,3,3,4,4,4} ，堆该数组进行赫夫曼树后，树化的顺序可能不同，会导致不同的赫夫曼树
   	
   实现
   	// 创建赫夫曼树
   	public class HuffmanCode {
      public static void main(String[] args) {
          String content = "i like like like jave do you like a java";
          byte[] bytes = content.getBytes();
          List<Node1> nodes = getNodes(bytes);
          Node1 huffmanTree = getHuffmanTree(nodes);
          huffmanTree.preOrder();
      }
  
      // 将所有的字符转换为一颗颗树
      public static List<Node1> getNodes(byte[] bytes) {
          Map<Byte, Integer> hashMap = new HashMap<>();
          for (byte aByte : bytes) {
              if (hashMap.get(aByte) == null) {
                  hashMap.put(aByte, 1);
              } else {
                  hashMap.put(aByte, hashMap.get(aByte) + 1);
              }
          }
          List<Node1> nodes = new ArrayList<>();
          for (Map.Entry<Byte, Integer> entry : hashMap.entrySet()) {
              nodes.add(new Node1(entry.getKey(), entry.getValue()));
          }
          return nodes;
      }
  
      // 得到赫夫曼树
      public static Node1 getHuffmanTree(List<Node1> list) {
          while (list.size() > 1) {
              Collections.sort(list);
              Node1 left = list.get(0);
              Node1 right = list.get(1);
              Node1 node1 = new Node1(left.getCount() + right.getCount());
              node1.setLeft(left);
              node1.setRight(right);
              list.remove(left);
              list.remove(right);
              list.add(node1);
          }
          return list.get(0);
      }
  }
  
  class Node1 implements Comparable<Node1> {
      private Byte data;
      private int count;
      private Node1 left;
      private Node1 right;
  
      @Override
      public String toString() {
          return "Node1{" +
                  "data=" + data +
                  ", count=" + count +
                  '}';
      }
  
      public Node1(int count) {
          this.count = count;
      }
  
      @Override
      public int compareTo(Node1 o) {
          return this.count - o.count;
      }
  
      // 前序遍历该树
      public void preOrder() {
          if (this == null) {
              return;
          }
          System.out.println(this);
          if (this.left != null) {
  
              this.left.preOrder();
          }
          if (this.right != null) {
  
              this.right.preOrder();
          }
      }
  
      public Node1(byte data, int count) {
          this.data = data;
          this.count = count;
      }
  
      public byte getData() {
          return data;
      }
  
      public void setData(byte data) {
          this.data = data;
      }
  
      public int getCount() {
          return count;
      }
  
      public void setCount(int count) {
          this.count = count;
      }
  
      public Node1 getLeft() {
          return left;
      }
  
      public void setLeft(Node1 left) {
          this.left = left;
      }
  
      public Node1 getRight() {
          return right;
      }
  
      public void setRight(Node1 right) {
          this.right = right;
      }
  }
  */
  ```

  ![image-20220226102706861](D:\typora_import_images\typora-user-images\image-20220226102706861.png)

  ![image-20220226103159865](D:\typora_import_images\typora-user-images\image-20220226103159865.png)

  ![image-20220226103953281](D:\typora_import_images\typora-user-images\image-20220226103953281.png)

  

  


#### 二叉排序树

+ 二叉排序树(BST:Binary Sort(Search) Tree)（排序）

  ```java
  /*
   介绍
   	对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大
   	
   实现
   	// 排序
   	public class BinarySortTree {
      public static void main(String[] args) {
          int[] arr = {7, 3, 10, 12, 5, 1, 9};
          BinaryTree binaryTree = new BinaryTree();
          for (int i = 0; i < arr.length; i++) {
              binaryTree.add(new Node(arr[i]));
          }
          binaryTree.infixOrder();
  
      }
  
  }
  
      class BinaryTree {
          public Node root;
  
          public void add(Node node) {
              if (root == null) {
                  root = node;
              } else {
                  root.add(node);
              }
          }
  
          public void infixOrder() {
              if (root == null) {
                  System.out.println("此二叉树为空");
                  return;
              }
              root.infixOrder();
          }
      }
  
      class Node {
          public Node left;
          public Node right;
          public Integer value;
  
          public Node(Integer value) {
              this.value = value;
          }
  
          @Override
          public String toString() {
              return "Node{" +
                      "value=" + value +
                      '}';
          }
  
          // 确定node所在的位置
          public void add(Node node) {
              if (node.value < this.value) {
                  // 放在this的左边
                  if (this.left != null) {
                      this.left.add(node);
                  } else {
                      this.left = node;
                  }
  
              } else {
                  if (this.right != null) {
                      this.right.add(node);
                  } else {
                      this.right = node;
                  }
                  // 放在this的右边
              }
          }
  
          // 中序遍历
          public void infixOrder() {
              if (this.left != null) {
                  this.left.infixOrder();
              }
              System.out.println(this);
              if (this.right != null) {
                  this.right.infixOrder();
              }
          }
      }
   注意
   	二叉排序树的查找和删除效率都非常高
   	数组 查找效率高，增删效率低
   	链表 增删效率高，查找效率低
   	
  */
  ```

  ![image-20220227160236981](D:\typora_import_images\typora-user-images\image-20220227160236981.png)



+ 二叉排序树(删除)

  ```java
  /*
  删除节点思路
  	当删除的目标是一个叶子节点时，只用找到它的节点和父节点即可删除(需要判断该节点位于哪一方)
  	当删除的目标是一个只有一颗子树的节点时，只用找到该节点，记录其子树，然后其父节点指向该子树即可
  	当删除的目标时一个有两颗子树的节点时，找到删除目标子树下的一个中点值(左子树的最右节点或右子树的最左节点)，然后记录待删除节点的左右子树，然后其父节点指向该中间值，中间值的左右节点指向记录的左右子树即可
  	
  实现
   public class BinarySortTree {
      public static void main(String[] args) {
          int[] arr = {7, 3, 10, 12, 5, 1, 9, 2};
          BinaryTree binaryTree = new BinaryTree();
          for (int i = 0; i < arr.length; i++) {
              binaryTree.add(new Node(arr[i]));
          }
  
          binaryTree.removeNode(7);
          binaryTree.removeNode(5);
      }
  
  }
  
  class BinaryTree {
      public static Node root;
  
      public void add(Node node) {
          if (root == null) {
              root = node;
          } else {
              root.add(node);
          }
      }
  
      public Node removeNode(int value) {
          return root.removeNode(value);
      }
  
      public void infixOrder() {
          if (root == null) {
              System.out.println("此二叉树为空");
              return;
          }
  
          root.infixOrder();
      }
  
      public Node search(int value) {
          if (root == null) {
              System.out.println("当前二叉树为空");
              return null;
          }
          return root.search(value);
      }
  
      public Node searchParent(int value) {
          if (root == null) {
              System.out.println("当前二叉树为空");
              return null;
          }
          return root.searchParent(value);
      }
  
  }
  
  class Node {
      public Node left;
      public Node right;
      public Integer value;
  
      public Node(Integer value) {
          this.value = value;
      }
  
      @Override
      public String toString() {
          return "Node{" +
                  "value=" + value +
                  '}';
      }
  
  
      // 删除节点 （返回被删除的节点）
      public Node removeNode(int value) {
          Node node = search(value);
  
          // 过滤掉节点中不存在该值的情况
          if (node == null) {
              return null;
          }
  
          // 如果删除的是根节点
          if (node == BinaryTree.root) {
              // 拿到之前根节点的左右节点
              Node left = node.left;
              Node right = node.right;
  
              // 如果左边节点为空则从右边获取值
              Node midValue = getLeftMaxValue(node);
              if (midValue == null) {
                  midValue = getRightValue(node);
              }
              // 如果待连接的(左)右节点和即将成为根节点的节点相同
              if (midValue == left || midValue == right) {
  
                  // 即将称为根节点的节点 和左边的节点相同
                  if (midValue == left) {
                      removeNode(left.value);
                      left = node.left;
                  }
                  // 即将成为根节点的节点 和右边的节点相同
                  if (midValue == right) {
                      removeNode(right.value);
                      right = node.right;
                  }
              }
              // 给新根节点连接左右节点
              midValue.left = left;
              midValue.right = right;
              // 移除当前root节点
              node.left = null;
              node.right = null;
              // 更新root节点
              BinaryTree.root = midValue;
              return node;
  
          }
  
          // 该值是一个叶子节点
          Node nodeParent = searchParent(value);
          if (node.left == null && node.right == null) {
              if (node == nodeParent.left) {
                  nodeParent.left = null;
              }
              if (node == nodeParent.right) {
                  nodeParent.right = null;
              }
              return node;
          } else if (node.left != null && node.right != null) { // 该值有两颗子树
              // 需要找一个该树中处在中等位置的一个值，该值位于 该树的左子树中的最右边的节点或右子树的最左边节点
              Node leftMaxValue = getLeftMaxValue(node);
              Node tmp = null; // 保存被删除的节点用于返回
              Node tmpChildTreeLeft = null; // 保存原有左子树
              Node tmpChildTreeRight = null; // 保存原有右子树
  
              // 删除的是左边这个子树
              if (nodeParent.left == node) {
  
                  // 保存删除被删除树之间的节点
                  tmp = nodeParent.left;
                  tmpChildTreeLeft = nodeParent.left.left;
                  tmpChildTreeRight = nodeParent.left.right;
                  nodeParent.left = leftMaxValue;
              } else { // 删除的是右边这个子树
                  tmp = nodeParent.right;
                  tmpChildTreeLeft = nodeParent.right.left;
                  tmpChildTreeRight = nodeParent.right.right;
                  nodeParent.right = leftMaxValue;
  
              }
              leftMaxValue.left = tmpChildTreeLeft;
              leftMaxValue.right = tmpChildTreeRight;
              return tmp;
  
          } else { // 该值有一颗子树
              if (nodeParent.left == node) { // 该节点是左子节点
                  if (node.left != null) {
                      nodeParent.left = node.left;
                  } else {
                      nodeParent.left = node.right;
                  }
              } else {  // 该节点是右子节点
                  if (node.left != null) {
                      nodeParent.right = node.left;
                  } else {
                      nodeParent.right = node.right;
                  }
              }
              return node;
          }
      }
  
      public Node getLeftMaxValue(Node node) {
          if (node.left == null) {
              return null;
          }
          Node tmp = node.left;
          while (tmp.right != null) {
              tmp = tmp.right;
          }
          // 删除该节点
          removeNode(tmp.value);
          return tmp;
      }
  
      public Node getRightValue(Node node) {
          if (node.right == null) {
              return null;
          }
          Node tmp = node.right;
          while (tmp.left != null) {
              tmp = tmp.left;
          }
          // 删除该节点
          removeNode(tmp.value);
          return tmp;
      }
  
      // 搜索当前节点的值9
      public Node search(int value) {
          if (this.value == value) {
              return this;
          }
          Node tmp = null;
          if (this.left != null && value < this.value) {
              tmp = this.left.search(value);
              if (tmp != null) {
                  return tmp;
              }
          }
          if (this.right != null && value > this.value) {
  
              tmp = this.right.search(value);
              if (tmp != null) {
                  return tmp;
              }
          }
          return null;
      }
  
      // 搜索父节点的值
      public Node searchParent(int value) {
          // 每次查找都会从当前节点的父节点开始查找
  
          // 左边节点不等于空 且该节点的值等于传入的值 说明找到该父节点
          if (this.left != null && (this.left.value == value)) {
              return this;
          }
          // 右边节点不等于空 且该节点的值等于传入的值 说明找到该父节点
          if (this.right != null && (this.right.value == value)) {
              return this;
          }
          // 否则执行以下语句
  
          Node tmp = null;
          // 如果传入的值小于该父节点，则从父节点的左边开始继续查找
          if (value < this.value) {
              if (this.left != null) {
                  tmp = this.left.searchParent(value);
                  if (tmp != null) {
                      return tmp;
                  }
              }
          } else {
              // 否则从父节点的右边开始查找
              if (this.right != null) {
                  tmp = this.right.searchParent(value);
                  if (tmp != null) {
                      return tmp;
                  }
              }
          }
          return null;
      }
  
      // 确定node所在的位置
      public void add(Node node) {
          if (node.value < this.value) {
              // 放在this的左边
              if (this.left != null) {
                  this.left.add(node);
              } else {
                  this.left = node;
              }
  
          } else {
              // 放在this的右边
              if (this.right != null) {
                  this.right.add(node);
              } else {
                  this.right = node;
              }
              // 放在this的右边
          }
      }
  
      // 中序遍历
      public void infixOrder() {
          if (this.left != null) {
              this.left.infixOrder();
          }
          System.out.println(this);
          if (this.right != null) {
              this.right.infixOrder();
          }
      }
  }
  */
  ```
  
  ![image-20220227173003192](D:\typora_import_images\typora-user-images\image-20220227173003192.png)
  
  ![image-20220227173007799](D:\typora_import_images\typora-user-images\image-20220227173007799.png)
  
  ![image-20220227173011732](D:\typora_import_images\typora-user-images\image-20220227173011732.png)



#### 平衡二叉树

+ 引入

  ![image-20220228171235000](D:\typora_import_images\typora-user-images\image-20220228171235000.png)
  
  ![image-20220302101557355](D:\typora_import_images\typora-user-images\image-20220302101557355.png)



+ 平衡二叉树

  ```java
  /*
   介绍
   	平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree) 又被称为 AVL树，可以保证查询效率较高
   	
   特点
   	平衡二叉树(AVL树)是一颗空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树，平衡二叉树的常用实现方法有 红黑树，AVL,替罪羊树，Treap,伸展树等
  
  */
  ```



+ 平衡二叉树-单旋转(左旋转)

  ![image-20220302122844625](D:\typora_import_images\typora-user-images\image-20220302122844625.png)
  
  ![image-20220302122947777](D:\typora_import_images\typora-user-images\image-20220302122947777.png)
  
  

  
  
  
  
  ![image-20220302102223652](D:\typora_import_images\typora-user-images\image-20220302102223652.png)



+ 平衡二叉树-右旋转

  ![image-20220302123323821](D:\typora_import_images\typora-user-images\image-20220302123323821.png)

  ![image-20220302123439779](D:\typora_import_images\typora-user-images\image-20220302123439779.png)





+ 双旋转(只有节点在 左子树的右边 || 右子树的左边时 才支持 双旋转 否则无法处理)

  如果添加的节点在左子树的右边或 右子树的左边，从而导致需要进行旋转时，此时需要进行双螺旋调整，要将 左子树的右边或 右子树的左边 旋转为 左子树的左边 或 右子树的右边 然后进行根节点旋转

  ![image-20220302153728521](D:\typora_import_images\typora-user-images\image-20220302153728521.png)

  
  
  节点在左子树的右边时
  
  ![image-20220302154622125](D:\typora_import_images\typora-user-images\image-20220302154622125.png)
  
  ![image-20220302154528551](D:\typora_import_images\typora-user-images\image-20220302154528551.png)
  
  ![image-20220302155030403](D:\typora_import_images\typora-user-images\image-20220302155030403.png)
  
  
  
  
  
  节点在右子树的左边
  
  ![image-20220302163214767](D:\typora_import_images\typora-user-images\image-20220302163214767.png)
  
  ![image-20220302163302350](D:\typora_import_images\typora-user-images\image-20220302163302350.png)
  
  ![image-20220302163401982](D:\typora_import_images\typora-user-images\image-20220302163401982.png)
  
  
  
  



+ 平衡二叉树实现

  ```java
  /*
   public class AVLTree {
      public static void main(String[] args) {
          BinaryTree binaryTree = new BinaryTree();
          // int[] arr = {4, 3, 6, 5, 7, 8}; // 右旋转情况
          //int[] arr = {10, 8, 12, 7, 9, 6};   // 左旋转情况
          //int[] arr = {10, 7, 12, 6, 8, 9};   // 局部旋转+左旋转情况
          int[] arr = {8, 7, 11, 10, 12, 9};  // 局部旋转+右旋转情况
          binaryTree.add(arr);
          System.out.println("树的高度" + binaryTree.treeHeight());
          System.out.println("左子树高度" + binaryTree.leftHeight());
          System.out.println("右子树高度" + binaryTree.rightHeight());
      }
  
  }
  
  class BinaryTree {
      public static Node root;
  
      // 添加到树节点中(包含平衡树判断)
      public void add(int[] arr) {
          for (int i = 0; i < arr.length; i++) {
              if (root == null) {
                  root = new Node(arr[i]);
              } else {
                  root.add(new Node(arr[i]));
              }
  
              // 每次添加完一个节点后，判断其是否需要(左，右)旋转
              if (root.rightHeight() - root.leftHeight() > 1) {
                  // 需要左旋转
  
  
                  // 每次添加完一个节点后，判断其是否需要局部旋转
                  if (root.right.left != null && root.right.left.left != null) {
                      root.rightPartRotate();
                  }
  
                  // 左旋转
                  root.leftRotate();
              }
              if (root.leftHeight() - root.rightHeight() > 1) {
                  // 需要右旋转
  
                  // 每次添加完一个节点后，判断其是否需要局部旋转(完成左边局部有序)
                  if (root.left.right != null &&root.left.right.right != null) {
                      root.leftPartRotate();
                  }
  
                  root.rightRotate();
              }
          }
  
      }
  
      public Node removeNode(int value) {
          return root.removeNode(value);
      }
  
      public void infixOrder() {
          if (root == null) {
              System.out.println("此二叉树为空");
              return;
          }
  
          root.infixOrder();
      }
  
      public Node search(int value) {
          if (root == null) {
              System.out.println("当前二叉树为空");
              return null;
          }
          return root.search(value);
      }
  
      public Node searchParent(int value) {
          if (root == null) {
              System.out.println("当前二叉树为空");
              return null;
          }
          return root.searchParent(value);
      }
  
      // 左子树局部旋转
      public void leftPartRotate() {
          this.root.leftPartRotate();
      }
  
      // 右子树局部旋转
      public void rightPartRotate() {
          this.root.rightPartRotate();
      }
  
      public int leftHeight() {
          if (root != null && root.left != null) {
              return root.leftHeight();
          }
          return -1;
      }
  
      public int rightHeight() {
          if (root != null && root.right != null) {
              return root.rightHeight();
          }
          return -1;
      }
  
      public int treeHeight() {
          if (root != null) {
              return root.height();
          }
          return -1;
      }
  
      public void leftRotate() {
          if (root != null && root.rightHeight() - root.leftHeight() > 1) {
              root.leftRotate();
              System.out.println("左旋转成功");
          }
      }
  
      public void rightRotate() {
          if (root != null && root.leftHeight() - root.rightHeight() > 1) {
              root.rightRotate();
              System.out.println("右旋转成功");
          }
      }
  }
  
  class Node {
      public Node left;
      public Node right;
      public Integer value;
  
      public Node(Integer value) {
          this.value = value;
      }
  
      @Override
      public String toString() {
          return "Node{" +
                  "value=" + value +
                  '}';
      }
  
      // 左子树高度
      public int leftHeight() {
          if (left == null) {
              return 0;
          }
          return this.left.height();
      }
  
      // 右子树高度
      public int rightHeight() {
          if (this.right == null) {
              return 0;
          }
          return this.right.height();
      }
  
      // 左子树局部旋转
      public void leftPartRotate() {
          Node moveNode = this.left; // 保留需要移动的左子树节点
          this.left = moveNode.right; // 根节点连接新的左子树节点
          moveNode.right = null; // 以前的左子树节点置空
  
          this.left.left = moveNode; // 新的左子树节点指向旧子树节点
  
      }
  
      // 右子树局部旋转
      public void rightPartRotate() {
          Node moveNode = this.right; //保留需要移动的右子树节点
          this.right = moveNode.left; // 根节点连接新的右子树节点
          moveNode.left = null; // 旧右子树节点 取消指向
          this.right.right = moveNode; // 新的右子树节点指向旧子树节点
      }
  
      // 左旋转(当右边的树高度大于左书高度时(右边树高度-左边树高度的绝对值大于1))
      public void leftRotate() {
          Node newRoot = this.right; // 记录新根节点
          this.right = newRoot.left; // 使旧根节点的右节点指向其左节点
          newRoot.left = this; // 使新节点的左节点指向旧节点
          BinaryTree.root = newRoot; // 设置新的节点
      }
  
      // 右旋转(当左边的树高度大于右书高度时(左边树高度-右边树高度的绝对值大于1))
      public void rightRotate() {
          Node newRoot = this.left; // 记录新根节点
          this.left = newRoot.right;// 使旧根节点的右节点指向其左节点
          newRoot.right = this; // 使新节点的右节点指向旧节点
          BinaryTree.root = newRoot; // 设置新的节点
  
      }
  
      // 返回以该节点开始计算树的高度
      public int height() {
          return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
      }
  
      // 删除节点 （返回被删除的节点）
      public Node removeNode(int value) {
          Node node = search(value);
  
          // 过滤掉节点中不存在该值的情况
          if (node == null) {
              return null;
          }
  
          // 如果删除的是根节点
          if (node == BinaryTree.root) {
              // 拿到之前根节点的左右节点
              Node left = node.left;
              Node right = node.right;
  
              // 如果左边节点为空则从右边获取值
              Node midValue = getLeftMaxValue(node);
              if (midValue == null) {
                  midValue = getRightValue(node);
              }
              // 如果待连接的(左)右节点和即将成为根节点的节点相同
              if (midValue == left || midValue == right) {
  
                  // 即将称为根节点的节点 和左边的节点相同
                  if (midValue == left) {
                      removeNode(left.value);
                      left = node.left;
                  }
                  // 即将成为根节点的节点 和右边的节点相同
                  if (midValue == right) {
                      removeNode(right.value);
                      right = node.right;
                  }
              }
              // 给新根节点连接左右节点
              midValue.left = left;
              midValue.right = right;
              // 移除当前root节点
              node.left = null;
              node.right = null;
              // 更新root节点
              BinaryTree.root = midValue;
              return node;
  
          }
  
          // 该值是一个叶子节点
          Node nodeParent = searchParent(value);
          if (node.left == null && node.right == null) {
              if (node == nodeParent.left) {
                  nodeParent.left = null;
              }
              if (node == nodeParent.right) {
                  nodeParent.right = null;
              }
              return node;
          } else if (node.left != null && node.right != null) { // 该值有两颗子树
              // 需要找一个该树中处在中等位置的一个值，该值位于 该树的左子树中的最右边的节点或右子树的最左边节点
              Node leftMaxValue = getLeftMaxValue(node);
              Node tmp = null; // 保存被删除的节点用于返回
              Node tmpChildTreeLeft = null; // 保存原有左子树
              Node tmpChildTreeRight = null; // 保存原有右子树
  
              // 删除的是左边这个子树
              if (nodeParent.left == node) {
  
                  // 保存删除被删除树之间的节点
                  tmp = nodeParent.left;
                  tmpChildTreeLeft = nodeParent.left.left;
                  tmpChildTreeRight = nodeParent.left.right;
                  nodeParent.left = leftMaxValue;
              } else { // 删除的是右边这个子树
                  tmp = nodeParent.right;
                  tmpChildTreeLeft = nodeParent.right.left;
                  tmpChildTreeRight = nodeParent.right.right;
                  nodeParent.right = leftMaxValue;
  
              }
              leftMaxValue.left = tmpChildTreeLeft;
              leftMaxValue.right = tmpChildTreeRight;
              return tmp;
  
          } else { // 该值有一颗子树
              if (nodeParent.left == node) { // 该节点是左子节点
                  if (node.left != null) {
                      nodeParent.left = node.left;
                  } else {
                      nodeParent.left = node.right;
                  }
              } else {  // 该节点是右子节点
                  if (node.left != null) {
                      nodeParent.right = node.left;
                  } else {
                      nodeParent.right = node.right;
                  }
              }
              return node;
          }
      }
  
      public Node getLeftMaxValue(Node node) {
          if (node.left == null) {
              return null;
          }
          Node tmp = node.left;
          while (tmp.right != null) {
              tmp = tmp.right;
          }
          // 删除该节点
          removeNode(tmp.value);
          return tmp;
      }
  
      public Node getRightValue(Node node) {
          if (node.right == null) {
              return null;
          }
          Node tmp = node.right;
          while (tmp.left != null) {
              tmp = tmp.left;
          }
          // 删除该节点
          removeNode(tmp.value);
          return tmp;
      }
  
      // 搜索当前节点的值9
      public Node search(int value) {
          if (this.value == value) {
              return this;
          }
          Node tmp = null;
          if (this.left != null && value < this.value) {
              tmp = this.left.search(value);
              if (tmp != null) {
                  return tmp;
              }
          }
          if (this.right != null && value > this.value) {
  
              tmp = this.right.search(value);
              if (tmp != null) {
                  return tmp;
              }
          }
          return null;
      }
  
      // 搜索父节点的值
      public Node searchParent(int value) {
          // 每次查找都会从当前节点的父节点开始查找
  
          // 左边节点不等于空 且该节点的值等于传入的值 说明找到该父节点
          if (this.left != null && (this.left.value == value)) {
              return this;
          }
          // 右边节点不等于空 且该节点的值等于传入的值 说明找到该父节点
          if (this.right != null && (this.right.value == value)) {
              return this;
          }
          // 否则执行以下语句
  
          Node tmp = null;
          // 如果传入的值小于该父节点，则从父节点的左边开始继续查找
          if (value < this.value) {
              if (this.left != null) {
                  tmp = this.left.searchParent(value);
                  if (tmp != null) {
                      return tmp;
                  }
              }
          } else {
              // 否则从父节点的右边开始查找
              if (this.right != null) {
                  tmp = this.right.searchParent(value);
                  if (tmp != null) {
                      return tmp;
                  }
              }
          }
          return null;
      }
  
      // 确定node所在的位置
      public void add(Node node) {
          if (node.value < this.value) {
              // 放在this的左边
              if (this.left != null) {
                  this.left.add(node);
              } else {
                  this.left = node;
              }
  
          } else {
              // 放在this的右边
              if (this.right != null) {
                  this.right.add(node);
              } else {
                  this.right = node;
              }
              // 放在this的右边
          }
  
  
      }
  
      // 中序遍历
      public void infixOrder() {
          if (this.left != null) {
              this.left.infixOrder();
          }
          System.out.println(this);
          if (this.right != null) {
              this.right.infixOrder();
          }
      }
  }
  */
  ```






#### 多路查找树

+ 引入

  ![image-20220302170853478](D:\typora_import_images\typora-user-images\image-20220302170853478.png)

  ![image-20220302174932876](D:\typora_import_images\typora-user-images\image-20220302174932876.png)

  

  

  

+ 2-3树

  ![image-20220302175402021](D:\typora_import_images\typora-user-images\image-20220302175402021.png)

  ```java
  /*
   2-3树值的插入规则
   	父节点可以是一个节点或两个节点组成 
   	子节点的第一个节点小于父节点的第一个节点;子节点的第二个节点大于第一个父节点，小于第二个父节点；子节点的第三个节点大于第二个父节点
   	所有叶子节点必须在同一层
   	有两个子节点的叫二节点，该节点要么有两个子节点，要么没有子节点
   	有三个子节点的叫三节点，该节点要么有三个子节点，要么没有子节点
   	当按照规则插入一个数到某个节点时，不能满足以上条件，则拆除本层，拆分后仍要满足以上条件
   	对于三节点的子树的值大小仍然遵守BST树(二叉排序树)的规则
   	
   注意
   	在创建2-3树时，要一直保证该树是一个2-3树
  */
  ```

  ![image-20220302190401438](D:\typora_import_images\typora-user-images\image-20220302190401438.png)

  ![image-20220302190729720](D:\typora_import_images\typora-user-images\image-20220302190729720.png)

  

  ![image-20220302191035028](D:\typora_import_images\typora-user-images\image-20220302191035028.png)

  

  

+ B树，B+树，B*树

  ![image-20220302191142365](D:\typora_import_images\typora-user-images\image-20220302191142365.png)

  ![image-20220302191329988](D:\typora_import_images\typora-user-images\image-20220302191329988.png)

  ![image-20220302191859942](D:\typora_import_images\typora-user-images\image-20220302191859942.png)

  ![image-20220302192020413](D:\typora_import_images\typora-user-images\image-20220302192020413.png)

  

  

### 1.9 图

+ 深度优先查找(从初始点开始查找，当找到了一个节点后，输出该节点，并以该节点为初始节点(进行一个行跳转)继续查找，直到所有节点查找完毕（已经输出的节点不会继续跳转))；广度优先查找(从初始(行)节点开始查找，找到一个节点后，输出该节点，然后继续从该初始节点(行)查找，直到所有节点遍历完毕，继续从下一行开始查找，直到所有节点查找完毕)

+ 引入

  ![image-20220303145347122](D:\typora_import_images\typora-user-images\image-20220303145347122.png)

  ![image-20220303145436833](D:\typora_import_images\typora-user-images\image-20220303145436833.png)

  

+ 概念(图)

  ![image-20220303145811915](D:\typora_import_images\typora-user-images\image-20220303145811915.png)

  ![image-20220303145902970](D:\typora_import_images\typora-user-images\image-20220303145902970.png)

  



+ 表示方式(图)

  **图的连通关系可以用二维数组表示，数值1表示连通，0表示不连通；row表示主连接节点，col表示被连接节点.如第一行(0) 和 1，2，3，4节点联通，第二行(1)和0，4联通，第三行(2)和0，4，5联通...**(该连通关系表示是否能直接连接)

  ![image-20220303150029593](D:\typora_import_images\typora-user-images\image-20220303150029593.png)

  ![image-20220303150703068](D:\typora_import_images\typora-user-images\image-20220303150703068.png)

  



+ 图的实现

  使用集合+二维数组构造一个图

  ```java
  /*
   public class Graph {
      /**
       * @description: 使用 ArrayList保存每个顶点，使用 edges[][] 来保存边与边的联系，1为连接，0为不连接
       *  ArrayList中索引的关系和edges的索引关系对应，如ArrayList中 0 位置为 "A",则edges中0位置也表示为 "A"
       * */
      public static void main(String[] args) {
          String[] vertex ={"A","B","C","D","E"};
          int n = 5;
          Graph myPractice = new Graph(n);
          for (String s : vertex) {
              myPractice.insertVertex(s);
          }
  
          // 建立边
          myPractice.buildEdge(0,1);
          myPractice.buildEdge(0,2);
          myPractice.buildEdge(1,2);
          myPractice.buildEdge(2,3);
          myPractice.buildEdge(2,4);
          myPractice.buildEdge(3,1);
          myPractice.buildEdge(3,4);
          myPractice.list();
      }
  
      private ArrayList<String> vertex; // 保存每个顶点
      private int[][] edges; // 和ArrayList中的索引对应，表示边和边的连接关系
      private int edgesNum; // 边的数量
  
      public Graph(int n) {
          vertex = new ArrayList<>(n);
          edges = new int[n][n];
      }
  
      // 展示连接关系
      public void list(){
          for (int[] edge : edges) {
              System.out.println(Arrays.toString(edge));
          }
      }
  
      // 返回总定点数
      public int vertexNums(){
          return vertex.size();
      }
  
      // 返回指定顶点的权
      public String getVertex(int n){
          return vertex.get(n);
      }
  
      // 得到顶点数目
      public int getEdgesNum() {
          return edgesNum;
      }
  
      // 添加顶点
      public void insertVertex(String value) {
          vertex.add(value);
      }
  
      // 建立边
      public void buildEdge(int v1, int v2) {
          edges[v1][v2] = 1; // 互相为边
          edges[v2][v1] = 1;
          edgesNum++;
      }
  }
  */
  ```



+ 图的深度优先(DFS)

  总结**图的深度优先，是一个纵向遍历方法，当遍历到一个邻接边时，会跳转到该边继续，开始遍历，当该行都没连接时，开始回溯，继续上层的邻接查找，直到结束**

  ![image-20220303161906422](D:\typora_import_images\typora-user-images\image-20220303161906422.png)

  
  
  ![image-20220303162803122](D:\typora_import_images\typora-user-images\image-20220303162803122.png)
  
  
  
  
  
+ 广度优先算法(BFS)

  ![image-20220303174212462](D:\typora_import_images\typora-user-images\image-20220303174212462.png)

  

  


+ 图的深度优先广度优先实现

  ```java
  /*
   public class Graph {
      /**
       * @description: 使用 ArrayList保存每个顶点，使用 edges[][] 来保存边与边的联系，1为连接，0为不连接
       * ArrayList中索引的关系和edges的索引关系对应，如ArrayList中 0 位置为 "A",则edges中0位置也表示为 "A"
       */
      public static void main(String[] args) {
          String[] vertex = {"A", "B", "C", "D", "E"};
          int n = 5;
          Graph graph = new Graph(n);
          for (String s : vertex) {
              graph.insertVertex(s);
          }
  
          // 建立边
          graph.buildEdge(0, 1);
          graph.buildEdge(0, 2);
          graph.buildEdge(1, 2);
          graph.buildEdge(2, 3);
          graph.buildEdge(2, 4);
          graph.buildEdge(3, 1);
          graph.buildEdge(3, 4);
          //  myPractice.list();
          // graph.dfs();
          graph.bfs();
      }
  
      private ArrayList<String> vertex; // 保存每个顶点
      private int[][] edges; // 和ArrayList中的索引对应，表示边和边的连接关系
      private int edgesNum; // 边的数量
      private boolean[] isVisited; // 记录某个节点是否被访问
  
      public Graph(int n) {
          vertex = new ArrayList<>(n);
          edges = new int[n][n];
          isVisited = new boolean[n];
      }
  
   // 找到第一个邻接节点
      private int getFirstVertex(int row){
          for (int i = 0; i < vertexLength(); i++) {
                  if(connect[row][i]>0){
                      return i; // 找到第一个邻接节点
                  }
          }
          return -1;
      }
  
      // 找到该行其他邻接节点
      private int getNextVertex(int row,int col){
          for (int i = col+1; i <vertexLength() ; i++) {
              if(connect[row][i]>0){
                  return i; // 返回下一个邻接节点
              }
          }
          return -1;
      }
      // 深度优先遍历
      // 深度优先遍历又指列优先遍历，每次找到一个邻接节点后，又会以该邻接节点开始进行扫描，
      // 可以看作是一个纵向扫描
  
      public void dfs(int i){
          System.out.print(getVertex(i)+" -> ");
          vertexState[i] = true; // 将该顶点置为true(表示已经处理)
          int w = getFirstVertex(i); // 获得该顶点(行)的第一邻接边
          while(w!=-1){  // 该顶点有邻接边
              if(!vertexState[w]){  // 判断该邻接边是否已经被输出
                  dfs(w); // 如果没有输出就将其输出(并跳转到该行，对改行的边继续输出)
              }
              w = getNextVertex(i,w); // 移动到该行的下一个邻接边，继续做判断
          }
      }
      public void dfs(){
          for (int i = 0; i < vertexLength(); i++) {
              if(!vertexState[i]){
                  dfs(i); // 遍历所有顶点，防止有边未连接的情况(导致不能正常遍历顶点)
              }
          }
      }
  
      // 得到所有端点长度
      public int vertxLength() {
          return vertex.size();
      }
  
    
  
  
       // 广度优先遍历
      // 广度优先指 行优先遍历，每次找到一个(未被处理的)邻接节点后，会将其加入队列尾部，待当该行的所有邻接顶点遍历完成后，再取出队列的首数据，再次进行遍历查找(未被处理的)邻接节点，再入队列，一直往复，直到所有顶点都被遍历
      // 跳转执行下一轮
      public void bfs(int i) {
          System.out.print(getVertex(i) + " -> ");
          vertexState[i] = true; // 将改行置为true
          LinkedList<Integer> linkedList = new LinkedList<>(); // 创建一个队列
          int u = 0;
          int a = 0;
          linkedList.addLast(i); // 新增添加到队列尾部
          while (!linkedList.isEmpty()) { // 如果队列不为空就一直遍历
              u = linkedList.removeFirst(); // 移除队列的第一顶点
              a = getFirstVertex(u); // 获得该顶点行的一个临边顶点
              while(a!=-1){ // 如果改行有邻接节点 就一直循环
                  if(!vertexState[a]){ // 如果改行邻接节点没有被处理接进行处理
                      System.out.print(getVertex(a)+" -> ");
                      vertexState[a] = true;
                      linkedList.addLast(a); // 把该行的邻接节点加入待遍历队列
                  }
                  a = getNextVertex(u,a); // 得到该行的下一个邻接顶点
              }
          }
      }
  
      public void bfs(){
          for (int i = 0; i < vertexLength(); i++) {
              if(!vertexState[i]){
                  bfs(i); // 遍历所有顶点，防止有边未连接的情况(导致不能正常遍历顶点)
              }
          }
      }
  
      // 展示连接关系
      public void list() {
          for (int[] edge : edges) {
              System.out.println(Arrays.toString(edge));
          }
      }
  
      // 返回总定点数
      public int vertexNums() {
          return vertex.size();
      }
  
      // 返回指定顶点的权
      public String getVertex(int n) {
          return vertex.get(n);
      }
  
      // 得到顶点数目
      public int getEdgesNum() {
          return edgesNum;
      }
  
      // 添加顶点
      public void insertVertex(String value) {
          vertex.add(value);
      }
  
      // 建立边
      public void buildEdge(int v1, int v2) {
          edges[v1][v2] = 1; // 互相为边
          edges[v2][v1] = 1;
          edgesNum++;
      }
  
  }
  */
  ```

  

+ 深度优先vs广度优先

  ![image-20220304112127871](D:\typora_import_images\typora-user-images\image-20220304112127871.png)

  





## 2.0 算法

### 前序

+ 暴力递归

  ![image-20220322122244007](D:\typora_import_images\typora-user-images\image-20220322122244007.png)

  

  

**Kruskal&&Dijkstra&&Floyd 算法未理解，其他大致掌握**

**算法(algorithm)**

+ 递归使用空间换时间来提高程序效率

### 2.1 排序算法



+ 介绍

  ```java
  /*
   排序也称 排序算法
   	排序是将一组数据，以指定的顺序进行排序的过程
   排序的分类
   	内部排序
   		指将需要处理的所有数据都加载到内部存储器中进行排序
   	外部排序法
   		数据量过大，无法全部加载到内存中，需要借助外部存储进行排序
  */
  ```

  ![image-20220213110628408](D:\typora_import_images\typora-user-images\image-20220213110628408.png)



+ 算法时间复杂度

  ```java
  /*
   度量一个程序(算法)执行时间的两种方法
   	事后统计法
   		这种方法可行，但有两个问题(程序过大可能导致运算过慢，依赖硬件)，此方式要在同一台计算机的相同状态下运行，才能比较哪个算法速度更快
  	事前估算法
  		通过分析某个算法的时间复杂度来判断哪个算法更优秀
  		
  
  时间频度
  	时间频度，一个算法花费的时间与算法中语句的执行次数成正比，哪个算法中语句执行次数多，它花费时间就多。一个算法中语句执行次数被称为 语句频度或时间频度，记为 T(n)
  	
  
  练习(时间频度估计)
  	public class AnalyseOfTimeFrequency {
      public static void main(String[] args){
          //1 . 时间频率为 T(n) = n+1   (n为for循环的次数 ，+1 为结束判断的运行次数)
          int total = 0;
          int end = 100;
          for (int i = 0; i < end; i++) {
              total+=1;
          }
  
          // 2. 时间频率为 T(n) = 1 (下一句为 直接计算,只用执行一次，所有频率为1)
          total =(1+end)*end/2;
          
          }
      }
  	
  注意
  	在一个时间频率的计算式中，可以忽略掉常数项,低次项和系数(因为这一百到几万次的差别对计算机来说时间很短(1ms-100ms))，如  T(n) = n+1 ，可以忽略为 T(n) = n ; 2n^2+3n+10 可以忽略为 2n^2; 5n^2+7n 可以需略为n^2  （次方不能忽略，其是一个指数值）
  	
  时间复杂度
  	一般情况下，算法中的基本操作语句的重复执行次数是问题n的某个函数，用T(n)表示，若有某个辅助函数f(n),使当n趋近于无穷大时，T(n)/f(n)的极限值不等于零的常数，则称f(n)是T(n)为同数量级函数，记作 T(n) = O(f(n))为该算法的时间复杂度
  
  计算时间复杂度的方法
  	用常数1代替运行时间中的所有加法常数
  	修改后的运行次数函数中，只保留最高阶项
  	去除最高阶项的系数
  	注意
  		时间频率去掉 常数，低次项和系数 就是时间复杂度，如 T(n) = 4n^2+2n+6 时间复杂度为 O(n^2)
  		
  常见的时间复杂度
  	常数阶 O(1)
  		无论代码执行多少行，只要没有使用循环等复杂结构，那这个代码的时间复杂度就是 O(1)
  		如
  			int i = 1;
  			int j= 2;
  			j++;
  			++i;
  			int m = i+j;
  		上述代码在执行的时候，它的消耗并不随着某个变量的增长而增长，那么无论这类代码有多长，即使几万到几	  十万行，他的时间复杂度都可以用 O(1)表示
  		
  	对数阶 O(log(n)n)
  		对数知识
  			如果 N = a^x(a>0,a!=1),即a的次方等于N(a>0,a!=1),那么数x叫做以a为底N的对数,记作x=log(a)N,其中,a叫做对数的底数，N叫做真数，x叫做以 a为底N的对数
  		对数练习
  			log(3)9 = 2;    log(2)8 = 3 ;   log(2)16/log(8)64 = 2;
  		如
  			int i = 1;
  			while(i < n) i *=2;
  		上述代码在 while循环里，每次i都乘2，乘完后，i距离n就越来越近了。假设循环x次后，i就大于n了，此循		环也就退出了。也就是说 2 的 x 次方等于 n ，那么 x = log(2)n就是上述代码的时间复杂度。
  	    注意
  	    	O(log(n)n)是根据代码的变化而变化的，如果 i*=3 则 时间复杂度为 O(log(3)n)
  	    	
  	线性阶 O(n)
  		如
  			int j = 1;
  			for(int i = 1; i <=10; i++)  j++; 
  		上述代码，for循环里的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的(如n为8此循环就执行8		  次，n为10此代码就执行10次),因此此类代码的时间复杂度为 O(n)
  		
  	线性对数阶 O(nlogn)
  		如
  			int n = 10;
  			for(int i = 1; i <=n;i++){
  				int j = 1;
  				while(j<n){
  					j*=2;
  				}
  			}
  		上述代码 为 for循环的时间复杂度为O(n)，里面的循环体 为  O(log(2)n) , 两者嵌套组合为 线性对数阶	  O(nlogn), 因此上述代码的 时间复杂度为 O(nlog(2)n) , 如果嵌套循环是 O(log(3)n)则时间复杂度为 		  O(nlog(3)n)。
  		
  	平方阶 O(n^2)
  		
  		如 
  			int n = 10;
  			for(int i = 1; i <=n;i++){
  				for(int j = 1; j <=n;j++){
  					System.out.print("1 ");
  				}
  			}
  		上述代码 由 两层随n变化而变化的循环，因此时间复杂度为 O(n^2) (当 n为 5 时 循环执行25次)
  	立方阶 O(n^3)
  		如 
  			int n = 10;
  			for(int i = 1; i <=n;i++){
  				for(int j = 1; j <=n;j++){
  					for(int e = 1; e <=n;e++){
  						System.out.print("1 ");
  					}
  				}
  			}
  		上述代码 有 三层随n变化而变化的循环，因此时间复杂度为 O(n^3) (当 n为 3 时 循环执行27次)
  	k次方阶 O(n^k)
  		O(n^k) 指 有 k层的循环进行了嵌套(这些循环的次数随n的变化而变化)
  	指数阶 O(2^n)
  	注意		
      常见的算法时间复杂度由小到大依次为：O(1)<O(logn)<O(n)<O(nlogn)< O(n^2)<O(n^3)<O(n^k)<O(2^n),时间复杂度越小效率越高，反之，时间复杂度越大效率越低
      
  注意
  	T(n)不同 但时间复杂度可能相同，如T(n) = n^2+7n+6 和 T(n)=3n^2+2n+2 他们的时间频率不同，但时间复杂度相同，都为 O(n^2)
  	在代码编写中，应该尽量使用时间复杂度低的算法
  	
  	
  	
  平均时间复杂度和最坏时间复杂度
  	平均时间复杂度指所有可能的输入情况下的等概率运行时间
  	最坏时间复杂度指，在输入最极端的值的情况。
  注意
  	一般讨论的时间复杂度为最坏情况下的时间复杂度，因为最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这保证了算法的运行时间不会比最坏的情况更长
  	
  	
  空间复杂度
  	时间复杂度指该算法所消耗的存储空间，也是问题规模n的函数
  	空间复杂度(space complexity)是对一个算法在运行过程中临时占用存储空间大小的度量
  注意
  	在做算法分析时，主要讨论的是时间复杂度，从用户体验来看，更看重的是程序执行的速度。一些缓存产品(redis，memecache)和算法(基数排序)本质就是用空间换时间
  */
  ```
  
  ![image-20220213112739666](D:\typora_import_images\typora-user-images\image-20220213112739666.png)
  
  ![image-20220213113805735](D:\typora_import_images\typora-user-images\image-20220213113805735.png)
  
  ![image-20220213113927854](D:\typora_import_images\typora-user-images\image-20220213113927854.png)
  
  ![image-20220213140211742](D:\typora_import_images\typora-user-images\image-20220213140211742.png)

![image-20220213153200356](D:\typora_import_images\typora-user-images\image-20220213153200356.png)





+ 冒泡排序

  ```java
  /*
   冒泡排序思想
   	通过对 待排序 序列从前向后(从下标较小元素开始),依次比较相邻元素的值，若发现逆序则交换，使较大的元素主键从前移向后部
   	因为排序的过程中，各元素不断接近自己的为止，如果一趟比较下来没有进行过交换，就说明序列有序，因此只要在排序过程中设置一个标志flag判断元素是否进行过交换，从而减少不必要的比较
   	
   实现
      public static void bubblingSort(int[] arr) { // 设  int[] arr = {1,3,2,4,5};
      	static int count;
          boolean flag = false; // 优化冒泡排序
          for (int i = 0; i < arr.length - 1; i++) {
              for (int j = 0; j < arr.length - i - 1; j++) {
                  if (arr[j] > arr[j + 1]) {
                      // 2 3 4 5 1 | 2 3 4 1 5 || 2 3 1 4 5 || 2 1 3 4 5 || 1 2 3 4 5
                      flag = true; // 记录是否交换过位置
                      arr[j] ^= arr[j + 1];
                      arr[j + 1] ^= arr[j];
                      arr[j] ^= arr[j + 1];
                  }
              }
              if(flag){
                  // 重置flag
                  flag = false;
              }else{
                  // 没有交换过位置 说明 此数组已经有序
                  break;
              }
              count++;
              System.out.println(count);
          }
          for (int i : arr) {
              System.out.print(i + " ");
          }
      }
  */
  ```

  



+ 选择排序

  ```java
  /*
   选择排序思路
   	第一次从 arr[0]-arr[n-1]中选取最小值，与arr[0]交换，第二次从 arr[1]-arr[n-1]取最小值，与arr[1]交换，第三次从 arr[2]-arr[n-1]中选取最小值，与arr[2]交换，...依此法完成交换后即可获得有序数组
   	
   实现
    public void selectSort(int arr[]){ // 设  int[] arr = {5,2,4,3,1};
          for(int i = 0; i < arr.length-1;i++){
              for (int j = i+1; j < arr.length; j++) {
           // 2 5 4 3 1 | 1 5 4 3 2 || 1 4 5 3 2 | 1 3 5 4 2 | 1 2 5 4 3 || 1 2 3 4 5 || 1 2 3 4 5
                  if(arr[i] > arr[j]){
                      arr[i]^=arr[j];
                      arr[j]^=arr[i];
                      arr[i]^=arr[j];
                  }
              }
          }
      }	
  */
  ```

  

+ 插入排序

  ```java
  /*
   插入排序属于内部排序法，将被排序元素以插入的方法寻找该元素的适当位置，以达到排序目的
   插入排序的基本思想
   	把n个待排序的元素看成一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含由n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使其成为新的有序表
   	
   实现
   	 public static void insertSort(int arr[]) { // 设 int[] arr = { 3,4,1,5,2}
          for (int i = 1; i < arr.length; i++) {
              // 3 4 1 5 2|| 3 1 4 5 2 | 1 3 4 5 2 || 1 3 4 2 5 | 1 3 2 4 5 | 1 2 3 4 5
              for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--) {
                  arr[j] ^= arr[j - 1];
                  arr[j - 1] ^= arr[j];
                  arr[j] ^= arr[j - 1];
              }
          }
  
      }
  */
  ```

  ![image-20220213181509686](D:\typora_import_images\typora-user-images\image-20220213181509686.png)



+ 希尔排序

  ```java
  /*
   介绍
   	希尔排序是 希尔 于 1959年提出的一种排序算法，希尔排序也是一种插入排序，它是简单插入排序经过改进后的一个更高效版本，也称 缩小增量排序
   	
   希尔排序基本思想
   	希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件x恰被分成一组，算法便终止了
   	希尔排序每次会把数组里的元素分成n组(n为数组长度/2),使每组的顺序有序,然后再此组数的基础上再除以2，再进行分组，使每组顺序有序，直到n为1时即对已经拍好序的位置在进行一次微调，即可达到数组有序
   	
   实现(交换法，效率较慢,效率不如插入排序)
   	  public static void shellSortOfExchange(int[] arr){
        // 设 int[] arr = {8,9,1,7,2,3,5,4,6,0};
             for(int len = arr.length/2;len >0; len /=2){
                 for (int i = len; i < arr.length; i++) {
                     for (int j = i-len; j >=0; j-=len) {
  
                         // 正确解法，以下为 将 最大(小)的按数组索引排序
                         if(arr[j+len]<arr[j]){
                             // [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
                             // [1, 5, 3, 6, 0, 8, 9, 4, 7, 2]
                             // [0, 5, 1, 6, 3, 8, 9, 4, 7, 2]
                             // [0, 4, 1, 5, 3, 6, 9, 8, 7, 2]
                             // [0, 4, 1, 5, 3, 6, 7, 8, 9, 2]
                             // [0, 4, 1, 5, 3, 6, 7, 2, 9, 8]
                             // [0, 4, 1, 5, 3, 2, 7, 6, 9, 8]
                             // [0, 4, 1, 2, 3, 5, 7, 6, 9, 8]
                             // [0, 2, 1, 4, 3, 5, 7, 6, 9, 8]
  
  
                             arr[j+len]^=arr[j];
                             arr[j]^=arr[j+len];
                             arr[j+len]^=arr[j];
                         }
  
                         // 错误解法 ，以下为 将 arr[i-n] 位置上 的最大值放到i位置上
  //                   if(arr[i]<arr[j]){
  //                       // [3, 5, 1, 6, 0, 8, 9, 4, 7, 2]
  //                       // [1, 5, 3, 6, 0, 8, 9, 4, 7, 2]
  //                       // [1, 5, 0, 6, 3, 8, 9, 4, 7, 2]
  //                       // [1, 5, 0, 6, 3, 4, 9, 8, 7, 2]
  //                       // [1, 5, 0, 6, 3, 4, 7, 8, 9, 2]
  //                       // [1, 5, 0, 6, 3, 4, 7, 2, 9, 8]
  //                       arr[i]^=arr[j];
  //                       arr[j]^=arr[i];
  //                       arr[i]^=arr[j];
                     }
                 }
             }
             
           System.out.println(Arrays.toString(arr));
           // 此时即为相对位置有序，此时使用插入排序即可
         }
         
    实现(移动法，效率高，优于插入排序)
     public static void shellSortOfMove(int[] arr) {
          for (int len = arr.length / 2; len > 0; len /= 2) {  // 把数组分成 len组，方便局部排序
              for (int i = len; i < arr.length; i++) {// 从当前分组的首元素 开始遍历
                  int j = i; // 记录当前分组元素的索引
                  int initValue = arr[j]; // 记录当前分组元素的值
                  if (arr[j] < arr[j - len]) { // 如果当前分组的索引 小于 当前的分组的前一个值 说明需要排序,否则不需要排序
                      while (j - len>= 0 && initValue < arr[j - len]) {
                          // j - len>= 0 && initValue < arr[j - len]
                          // j - len>= 0  表示 j - le 索引需 >=0
                          // initValue < arr[j - len] 表示 当前位置 小于 其组内上一个索引位置的值时 就继续以下操作
  
  
                          arr[j] = arr[j - len]; // 上一个步长位置上的值 移动到 当前位置上上
                          j -= len; // j 向后移动
                      }
                      arr[j] = initValue;  // 找到当前分组初始值插入语的位置进行插入
                  }
              }
          }
      }
    	
    	// 希尔排序过程
    	    3 2 4 1 5
          3 3 4 1 5
          2 3 4 1 5
          2 3 4 4 5
          2 3 3 4 5
          2 2 3 4 5
          1 2 3 4 5
  */
  ```
  
  ![image-20220214153116695](D:\typora_import_images\typora-user-images\image-20220214153116695.png)
  
  ![image-20220214153229244](D:\typora_import_images\typora-user-images\image-20220214153229244.png)





+ 快速排序(quickSort)

  ```java
  /*
   介绍
   	快速排序是对冒泡排序的一种改进
   基本思想
   	通过一趟排序将要排序的数据分割成独立的两部分。其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对着两部分数据分别进行快速排序，整个排序过程可以递归进行，以达到整个数组有序
   	
   	
   使用
      快速排序(以首部为参考点)
        public static void qs(int[] arr, int left, int right) {
          if (left >= right) {
              return;
          }
          int l = left;
          int r = right;
          int pivot = arr[left];
          while (true) {
  
              // 当参考数为首部索引时, 每次查找 都必须从后往前找(再从前往后找)，这样才能落到正确的点位上
              // （1）因为 如果先从前往后找(按小到大顺序排) 最终会先落到一个较大的数上，然后会将较大的数放到首部，导致数据排序错误
              //      而从后往前找不会，它最终会落到一个较小的数上，然后和首部进行交换
              // （2）因为 如果先从前往后找(按大到小顺序排) 最终会先落到一个较小的数上，然后会将较小的数放到首部，导致数组排序错误
              //      而先从后往前找不会，它最终会落到一个较大的数上，然后和首部进行交换
  
              // 当参考数为尾部索引时，每次查找 都必须从前往后找(再从后往前找)，这样才能落在正确的点位上
              // （1）因为 如果先从后往前找(按小到大顺序排) 最终会先落到一个较小的数上，然后会将较小的数放到尾部，导致数据排序错误
              //      而从前往前找不会，它最终会落到一个较大的数上，然后和尾部进行交换
              // （2）因为 如果先从后往前找(按大到小顺序排) 最终会先落到一个较大的数上，然后会将较大的数放到尾部，导致数组排序错误
              //      而先从前往后找不会，它最终会落到一个较小的数上，然后和尾部进行交换
  
              // 找到一个大于pivot的点位(从后往前找)
              while (arr[r] <= pivot && l < r) {
                  r--;
              }
  
              // 找到一个小于pivot的点位(从前往后找)
              while (arr[l] >= pivot && l < r) {
                  l++;
              }
  
              // 当两个点位在一起时，说明已经局部有序，交换首部的值
              if (l == r) {
                  break;
              }
  
              // 交换两个值
              int temp = arr[l];
              arr[l] = arr[r];
              arr[r] = temp;
  
          }
  
          // 和临界点位交换，达到局部有序
          arr[left] = arr[l];
          arr[l] = pivot;
  
          // 此时 指针指向一个点位(索引),该点位已经有序,l-1向左边遍历
          qs(arr, left, l - 1);
          // 此时 指针指向一个点位(索引),该点位已经有序,r+1向右边遍历
          qs(arr, r + 1, right);
      }
      
     快速排序(以尾部为参考点)
     	 public static void qs(int[] arr, int left, int right) {
          if (left > right) {
              return;
          }
          int l = left;
          int r = right;
          int pivot = arr[right];
          while (true) {
  
              // 当参考数为首部索引时, 每次查找 都必须从后往前找(再从前往后找)，这样才能落到正确的点位上
              // （1）因为 如果先从前往后找(按小到大顺序排) 最终会先落到一个较大的数上，然后会将较大的数放到首部，导致数据排序错误
              //      而从后往前找不会，它最终会落到一个较小的数上，然后和首部进行交换，达到有序
              // （2）因为 如果先从前往后找(按大到小顺序排) 最终会先落到一个较小的数上，然后会将较小的数放到首部，导致数组排序错误
              //      而先从后往前找不会，它最终会落到一个较大的数上，然后和首部进行交换，达到有序
  
              // 当参考数为尾部索引时，每次查找 都必须从前往后找(再从后往前找)，这样才能落在正确的点位上
              // （1）因为 如果先从后往前找(按小到大顺序排) 最终会先落到一个较小的数上，然后会将较小的数放到尾部，导致数据排序错误
              //      而从前往前找不会，它最终会落到一个较大的数上，然后和尾部进行交换
              // （2）因为 如果先从后往前找(按大到小顺序排) 最终会先落到一个较大的数上，然后会将较大的数放到尾部，导致数组排序错误
              //      而先从前往后找不会，它最终会落到一个较小的数上，然后和尾部进行交换
  
              // 找到一个大于pivot的点位(从前往后找)
              while (arr[l] <= pivot && l < r) {
                  l++;
              }
  
              // 找到一个小于pivot的点位(从后往前找)
              while (arr[r] >= pivot && l < r) {
                  r--;
              }
  
  
  
              // 当两个点位在一起时，说明已经局部有序，交换尾部的值
              if (l == r) {
                  break;
              }
  
              // 交换两个值
              int temp = arr[l];
              arr[l] = arr[r];
              arr[r] = temp;
  
          }
  
          // 和临界点位交换，达到局部有序
          arr[right] = arr[l];
          arr[l] = pivot;
  
          // 此时 指针指向一个点位(索引),该点位已经有序,l-1向左边遍历
          qs(arr, left, l - 1);
          // 此时 指针指向一个点位(索引),该点位已经有序,r+1向右边遍历
          qs(arr, r + 1, right);
      }
  
     */
  ```
  
  ![image-20220215163344189](D:\typora_import_images\typora-user-images\image-20220215163344189.png)



+ 归并排序

  ```java
  /*
   介绍
   	归并排序 是 利用 归并的思想实现的排序方法，该算法采用经典的分治策略来求解
   
   基本思想
   	将需要排序的数组进行多次二分递归，直到分解到 每组包含 2 个 数据时，开始进行排序，使他们局部有序，然后对其他分组继续排序达到局部有序，最终向上总和，再进行排序，达到局部有序，往复如此，最终再继续最后一次向上总和达到整体有序
   
   使用
   	  public static void mergeSort(int[] arr, int left, int right) {
          if (left < right) { // 当left 小于 right 表示可以继续二分
              int mid = (right - left) / 2 + left;    // 取本组的中位点
              mergeSort(arr, left, mid, temp); // 以本组中位点开始左边部分二分
              mergeSort(arr, mid + 1, right, temp); // 以本组中位点开始右边二分
              merge(arr, left, mid, right, temp); // 开始对每组的二分进行排序
          }
      }
  
      private static void merge(int[] arr, int left, int mid, int right) {
          int[] temp = new int[right-left+1];
          int l = left; // 开始排序的左索引
          int r = mid + 1; // 开始排序的右索引
          int t = 0;  // 临时数组索引初始化
  
          while (l <= mid && r <= right) {
              //  l <= mid && r<=right 表示 左边和右边都有数据没遍历完
  
              // 两边的数据进行比较 谁小 则将先存放到临时数组中
              if (arr[l] < arr[r]) {
                  temp[t++] = arr[l++];
              } else {
                  temp[t++] = arr[r++];
              }
          }
  
          // 再两边数据比较完后 最终会有一边的数据还有数据，一边没有数据，此时我们需要再进行一次判断
          while (l <= mid) {
              temp[t++] = arr[l++];
          }
          while (r <= right) {
              temp[t++] = arr[r++];
          }
  
          // 此时temp 已经 存储着局部有序的数据，这时即可存入原数据的局部
          t = 0; // 重置 t 到首索引 方便存入数据(此时t为temp的空索引位置)
          
          int cur = left; // cur拿到当前分组(二分)的首位置
          // 当 cur <=right 表示此时 再该分组的有效索引位置上，否则就结束
          while(cur <=right){
              // 将 对arr局部有序的temp数组的数据传入给arr的指定位置
              arr[cur++] = temp[t++];
          }
  
      }
  */ 
  ```
  
  ![image-20220217181919099](D:\typora_import_images\typora-user-images\image-20220217181919099.png)
  
  ![image-20220217182103809](D:\typora_import_images\typora-user-images\image-20220217182103809.png)







+ 基数排序(桶排序)  radixSort  

  **有负数的数组不能使用基数排序！！**

  ```java
  /*
  介绍
    基数排序 属于 分配式排序  。又称 桶子排序(bucket sort) ,它是通过键值的各个位的值，将要排序的元素分配到指定 桶中 ，达到排序的作用
    基数排序是属于稳定性的排序，基数排序法是效率高的稳定性排序法
    基数排序是桶排序的扩展
    基数排序是 1887 年 被 赫尔曼·何乐礼发明的，实现方法：将整数按位数切割成不同的数据，然后按每个数分别比较
    
   基本思想
    将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行依次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成了一个有序序列
    
    使用
    	 public static void radixSort(int[] arr) {
          // 定义一个二维数组 表示10个桶 [] 表示每个桶(0-9) ,[][] 表示每个桶(0-9)里的数据
          // 然后每个桶的容量为 arr.length ,因为其内容可能有多个相同的值，要避免最坏的情况发生（多个数位上的值相同）
          int[][] bucket = new int[10][arr.length];
  
          // 为了记录每个桶中，实际存放的数据，需要定义一个一位数组来记录各个桶每次存放的数据
          int[] bucketElementCounts = new int[10]; // 0 索引存储着 0 桶的数据个数 ； 1 索引存储着 1 桶的 数据个数...
  
          // 得到该数组中最大的数
          int max = arr[0];
          for (int i = 1; i < arr.length; i++) {
              if (max < arr[i]) {
                  max = arr[i];
              }
          }
  
          int maxLength = (max + "").length(); // 得到最大数的长度
  
  
          // p为需要比较的轮数.n为对应比较位上的步长 第一轮为 1 ，第二轮为 10，第三轮为 100 ...
          for (int p = 0, n = 1; p < maxLength; p++, n *= 10) {
  
              // 进行 数位上的排列
              for (int i = 0; i < arr.length; i++) {
                  int bucketIndex = arr[i] / n % 10; // 拿到n位数，并放到对应的桶中
                  // 放到对于桶的对于索引上 ，bucketElementCounts[bucketIndex] 为当前桶的元素个数
                  // bucketElementCounts[bucketIndex]++ 为记录当前桶的元素个数
                  bucket[bucketIndex][bucketElementCounts[bucketIndex]++] = arr[i];
              }
  
              int index = 0;
              // 将 数位上排列后的值反馈给arr
              for (int k = 0; k < bucketElementCounts.length; k++) {
                  if (bucketElementCounts[k] > 0) { // 如果当前桶的数据个数大于0 说明有数据
                      // 遍历拿出数据 到arr 中，此时 arr数据里所有数的个位数就有序了
                      for (int l = 0; l < bucketElementCounts[k]; l++) {
                          arr[index++] = bucket[k][l];
                      }
                      bucketElementCounts[k] = 0; // 重置当前桶的个数(桶中的数据还在，我们指向重置了索引，以便覆盖元素)
                  }
              }
          }
      }
   注意
   	稳定性指 有相同的数据 再排序后数据的顺序仍然有序  如  1(e) 3 1(w) 4 ，排序后 为 1(e) 1(w) 3 4,两个相同的数据再排序后的顺序仍然有序(e,w为相同数据的标签，用于区别相同数据)
   	由于基数排序的排序策略是以空间换时间，所以当遍历的数据足够大时，我们也会开辟一个足够大的数组来存储数据，这时可能导致内存溢出错误
   	有负数的数组不能使用基数排序！！
  */
  ```

  ![image-20220218203835107](D:\typora_import_images\typora-user-images\image-20220218203835107.png)

  ![image-20220218204214146](D:\typora_import_images\typora-user-images\image-20220218204214146.png)

  ![image-20220218204237865](D:\typora_import_images\typora-user-images\image-20220218204237865.png)

  ![image-20220218204302864](D:\typora_import_images\typora-user-images\image-20220218204302864.png)



+ 堆排序

  ```java
  /*
   介绍
   	堆排序是利用对这种数据结构而设计的一种排序算法，堆排序是一种选择排序，他的最好,最坏和平均时间复杂度为O(nlogn) ，是一个不稳定的排序
   	堆是具有以下性质的完全二叉树，每个节点的值都大于或等于其左右子节点的值，称为大顶堆(不要求其左子节点和右子节点大小)
   	每个节点的值都小于或等于其左右子节点的值，称为小顶堆
   	
   基本思想
   	将排序序列构建成一个大顶堆。
   	此时，整个序列的最大值就是堆顶的根节点，
   	将其与末端元素进行交换，此时末尾就是最大值
   	然后将剩余n-1元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了
   	
   实现思路
   	每次从树的底层，比较出一个局部大(小)的值作为他们的父节点，一直向上比较直到比较到根节点，此时就找到了最大(小)的数，此时该数和末尾节点交换 然后下次在查找时不看该数即可，往复上述步骤直到达到全部数据有序
   	
   实现
   	public class HeapSort {
      public static void main(String[] args) {
          //int[] arr = {4, 6, 8, 5, 9};
          int[] arr =RandomArray.randomArray(10);
          heapSort(arr);
          System.out.println(Arrays.toString(arr));
  
      }
  
      // 将一个数组(二叉树)，调整为一个大顶堆
  
      public static  void heapSort(int[] arr){
          // 找出二叉树中大堆顶的数, i = arr.length/2-1 表示从一个非叶子节点开始比对，当i=0时，最终会将该树中最大数放到大堆顶
          // 此for循环排序过后，所有的点位已经放到了相对有序的位置
          for (int i = arr.length/2-1; i >=0 ; i--) { 
          
              adjustHeap(arr,i, arr.length);
          }
  
          // 每次将堆顶的值移动到数组数组尾部(最大数放到length,第二大数放到length-1,第三大数放到Length-2...)直到全部有序
          for (int j = arr.length-1; j >0 ; j--) {
              // 将大堆顶的树放到尾部
              arr[0]^=arr[j];
              arr[j]^=arr[0];
              arr[0]^=arr[j];
  
              // 继续从 0 —— j位置找一个最大数放到大堆顶
              adjustHeap(arr,0,j);
          }
      }
  
      /**
       * @param arr    需要调正的数组
       * @param i      表示非叶子节点在数组中索引
       * @param length 表示对多少个元素进行调正
       */
  
      /*
      *  过程解析： 每次调用此方法会将数组中的一个length范围的最大数放到大堆顶(首索引位置),然后i位置的值会被放到合适位置
     
      private static void adjustHeap(int[] arr, int i, int length) {
          int temp = arr[i]; // 取出当前值
  
          // 每次调正一个局部大顶堆 ， 当上一个大顶堆的值被换下来后，再将该值移动到合适的局部堆位置
          for (int j = i * 2 + 1; j < length; j = j * 2 + 1) {
  
              // 比较两个左右子节点谁大
              if (j + 1 < length && arr[j] < arr[j + 1]) {
                  // 左子节点
                  j++;
              }
  
              // 较大子节点和父节点比较
              if(arr[j]>temp){ // 如果条件成立
                  arr[i] = arr[j]; //  则把较大子节点的值放到父节点上
                  i = j; // i得到替换节点的索引，记录准备移动得位置
              }else{ // 如果条件不成立，说明该子树的已经找到了局部大顶堆
                  break;
              }
  
          }
  
          // 把temp(即原来位置的值)放到它该放到的位置(如果是局部最大数则i不会改变，否则该数会被放到某子节点位置)
          arr[i] = temp;
      }
  }
   注意
   	树和数组可以相互转换
   	
  */
  ```

  ![image-20220224155323709](D:\typora_import_images\typora-user-images\image-20220224155323709.png)
  
  ![image-20220224155523553](D:\typora_import_images\typora-user-images\image-20220224155523553.png)





+ 时间复杂度比对

  ```java
  /*
    相关术语
    	稳定性指 有相同的数据 再排序后数据的顺序仍然有序  如  1(e) 3 1(w) 4 ，排序后 为 1(e) 1(w) 3 4,两个相同的数据再排序后的顺序仍然有序(e,w为相同数据的标签，用于区别相同数据)，反之则为不稳定
    	内排序 ，所有排序操作都在内存中完成
    	外排序，由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传入才能进行
    	时间复杂度， 一个算法执行所消耗的时间
    	空间复杂度， 运行完一个程序所需要的内存大小
    	n 数据规模
    	k 桶的个数
    	in-place 不占用额外内存
    	out-place 占用额外内存
    	
    注意
    	冒泡排序 ，选择排序，插入语排序 平均时间复杂度为 平方阶；希尔排序，归并排序，堆排序，快速排序的 平均时间复杂度为线性对数阶；基数排序的平均时间复杂度为 n * k
  */
  ```

  ![image-20220218105128111](D:\typora_import_images\typora-user-images\image-20220218105128111.png)



+ 排序选择方向

  ```java
  /*
   如果想要稳定性 就选择归并排序，想要 空间复杂度最小 选择堆排序，想要 运行时间相对最快 快速排序
  */
  ```

  ![image-20220320145342626](D:\typora_import_images\typora-user-images\image-20220320145342626.png)



### 2.2 查找算法

+ 介绍

  ```java
  /*
   java中常用查找算法有  顺序(线性)查找，二分查找，插值查找，斐波那契查找
  */
  ```

  

+ 线性查找

  ```java
  /*
   即遍历数组中的元素进行逐一比对，来进行查找
   使用
   	public static boolean seqSearch(int[] arr, int target) {
          for (int i = 0; i < arr.length; i++) {
              if (target == arr[i]) {
                  return true;
              }
          }
          return false;
      }
  */
  ```

  

+ （递归）二分查找

  ```java
  /*
   二分查找是对一个有序数组进行二分查找，此方法可以快去定位并查找
   
   二分查找思路
   	首先确定该数组的中间下标,(right-left)/2+left
  	如果查找的值 小于 中间值 就在数组的左边继续查找
  	如果查找的值 大于 中间值 就在中间值的右边继续查找
  	如果查找的值 等于 中间值 说明已经找到返回该值
  	
   实现
   	// 查找该数是否在数组中
   	public static boolean binarySearch(int[] arr, int target, int left, int right) {
          if (left < 0 || right < 0) { // 输入错误
              throw new RuntimeException("输入索引错误");
          }
  
          // 表示再数组内
          if (left <= right) {
  
              // 拿到中点索引和中间值
              int mid = (right - left) / 2 + left;
              int pivot = arr[mid];
  
              if (pivot == target) { // 如果相等 说明找到
                  return true;
              }
  
              if (target < pivot) { // 小于中间则在中间的左边继续查找
                  return binarySearch(arr, target, left, mid - 1);
              } else {// 小于中间则在中间的右边继续查找
                  return binarySearch(arr, target, mid + 1, right);
              }
          }
          // 超出数组查找范围 退出查找
          return false;
      }
      
      
     // 返回多个查找到的索引
     public static ArrayList binarySearchList(int[] arr, int target, int left, int right) {
          if (left < 0 || right < 0) { // 输入错误
              throw new RuntimeException("输入索引错误");
          }
  
          // 表示再数组内
          if (left <= right) {
  
              // 拿到中点索引和中间值
              int mid = (right - left) / 2 + left;
              int pivot = arr[mid];
  
              if (pivot == target) { // 如果相等 说明找到
                  ArrayList<Integer> integers = new ArrayList<>();
                  integers.add(mid);
                  // 从 查找值的左边遍历 看其左边是否右相同的值
                  for (int i = mid - 1; i >= left && arr[i] == pivot; i--) {
                      integers.add(i);
                  }
                  // 从 查找值的左边遍历 看其左边是否右相同的值
                  for (int i = mid + 1; i <= right && arr[i] == pivot; i++) {
                      integers.add(i);
                  }
                  return integers;
              }
  
              if (target < pivot) { // 小于中间则在中间的左边继续查找
                  return binarySearchList(arr, target, left, mid - 1);
              } else {// 小于中间则在中间的右边继续查找
                  return binarySearchList(arr, target, mid + 1, right);
              }
          }
          // 超出数据 退出查找
          return null;
      }
  注意
  	使用二分查找时，需要保证数组已经有序
  */ 
  ```


+ 非递归二分查找

  ![image-20220304113212111](D:\typora_import_images\typora-user-images\image-20220304113212111.png)

  ```java
  /*
   public class BinarySearchNoRecursion {
      public static void main(String[] args) {
          int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9};
          int target = 3;
          int i = binarySearch(arr, target);
          System.out.println(i >= 0 ? target + "在数组的" + i + "位置" : "该数不存在");
      }
  
      public static int binarySearch(int[] arr, int target) {
          int left = 0;
          int right = arr.length - 1;
          while (left <= right) {
              int mid = (right - left) / 2 + left;
              if (arr[mid] == target) {
                  System.out.println("目标已找到");
                  return mid;
              }
              if (target < arr[mid]) {
                  right = mid - 1;
              }
              if (target > arr[mid]) {
                  left = mid + 1;
              }
          }
          return -1;
      }
  }
  */
  ```

  

+ 插值查找

  ```java
  /*
   介绍
   	插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找
   	将折半查找中的求 mid 索引的公式， low 表示左边索引, high 表示右边索引
   
   自适应 mid 公式  
   	left+(right-left)*(keyVal-arr[left])/(arr[right]-arr[left])
   	
   使用
   	public static boolean insertValueSearch(int[] arr, int left, int right, int keyValue) {
          if (left > right || keyValue < arr[0] || keyValue > arr[arr.length - 1]) {
              return false;
          }
  
          // 自适应中点公式
          int mid = left + (right - left) * (keyValue - arr[left]) / (arr[right] - arr[left]);
          if (keyValue == arr[mid]) { // 相等 ，说明此自适应中点就是查找的值
              return true;
          }
          if (keyValue > arr[mid]) { // 向 右自适应
              return insertValueSearch(arr, mid + 1, right, keyValue);
          } else { // 向左 自适应查找中点
              return insertValueSearch(arr, left, mid - 1, keyValue);
          }
      }
      
   使用场景
   	对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快，关键字分布不均匀则速度可能没有二分查找快 (不均匀指 数与数之间的差值很大，如 1,3,1000,1004,20000,800000，此时推荐使用二分查找；如果是连续的，关键字均与则使用插值查找比较快 如 1,2,3,4,5,6,7,8,9,10,11,12...)
   注意
   	插值查找算法也要求数组有序
   	插值查找使用自适应mid公式后比二分查找更快的定位到了查找点 
   	插值查找，查找多个数据和二分查找,查找多个数据思路相同,只用在查找点左右在遍历一遍即可找出相同值的索引
   	
  */
  ```

  ![image-20220219140823388](D:\typora_import_images\typora-user-images\image-20220219140823388.png)

  ![image-20220219151008541](D:\typora_import_images\typora-user-images\image-20220219151008541.png)



+ 斐波那契(黄金分割)查找算法

  ```java
  /*
   介绍
   	黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618.由于按此比例设计的造型十分美丽，因此被称为黄金分割，也称为 中外比
   	斐波那契数列{1，1，2，3，5，8，13，21，34，55} 发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618
   	
   斐波那契(黄金分割法)原理
   	斐波那契查找原理与前两种相似，仅仅改变了中间节点的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即 mid = low + F[k-1]-1 (F代表斐波那契数列)
   	
   使用
   	    // 得到Fibonacci数列
      public static int[] fib(int length) {
          int[] arr = new int[length];
          arr[0] = 1;
          arr[1] = 1;
          for (int i = 2; i < length; i++) {
              arr[i] = arr[i - 1] + arr[i - 2];
          }
          return arr;
      }
  
  
      public static int fibSearch(int[] a, int key) {
          int low = 0;
          int high = a.length - 1;
          int k = 0; // 表示斐波那契分隔数值的下标
          int mid = 0;
          int[] f = fib(20);
  
          // 找到斐波那契分隔数值的下标
          while (high > f[k] - 1) {
              k++;
          }
  
          // 因为f[k] 的值 可能大于 a 的长度  ，因此需要可能一个数组来临时存储数值
          int[] temp = Arrays.copyOf(a, f[k]);
          // 如果临时数组长度大于a数组长度，则多余的部分用a最后一个值来填充
          // 如  1 4 5 6 0 0 0    变为 1 4 5 6 6 6 6
          // 3*3-2/(2*3+2+(23-1))   3 3 * 2 2 3 * 2 + 23 1 - + / -
          for (int i = high + 1; i < temp.length; i++) {
              temp[i] = a[high];
          }
  
          while (low <= high) {
              mid = low + f[k - 1] - 1;
              if (key < temp[mid]) {
                  high = mid - 1;
                  k--; // 更改分隔点的位置
              } else if (key > temp[mid]) {
                  low = mid + 1;
                  k -= 2;
              } else {
                  if (mid <= high) {
                      return mid;
                  } else {
                      return high;
                  }
              }
          }
          return 0;
      }
      
  注意
  	排序的数组需要是有序的
  */
  ```

  ![image-20220219153743706](D:\typora_import_images\typora-user-images\image-20220219153743706.png)





### 2.3 分治算法

+ **将一个大规模问题分解成若干个规模较小的相同子问题，，以便逐个击破分而治之**

+ 介绍

  ![image-20220304140307832](D:\typora_import_images\typora-user-images\image-20220304140307832.png)

  ![image-20220304140448967](D:\typora_import_images\typora-user-images\image-20220304140448967.png)

  ![image-20220304140543037](D:\typora_import_images\typora-user-images\image-20220304140543037.png)

  

  

+ 分治法解决汉诺塔问题

  ```java
  /*
   public class HanoiTower {
      public static void main(String[] args) {
          move(3,"A","B","C");
      }
  
      public static void move(int nums, String a, String b, String c) {
          // 使用分治法解决汉诺塔问题
          // 将汉诺塔的n层看成两个部分，即 最底层的一个部分，和其上的一部分
          if (nums == 1) {
              // 说明此时只有最底层的一个盘，将其移动到c计科
              System.out.println("第1个盘子移动到" + c);
          } else {
              // 移动其上部分
              move(nums - 1, a, c, b); // 将c位置的盘子借助c移动到b
              System.out.println("第" + nums + "个盘子从" + a + "->" + c);
              move(nums - 1, b, a, c);// 将b位置的盘子借助a移动到c
          }
      }
  }
  */
  ```





#### 暴力递归到动态规划

+ 我的动态规划理解

  ```java
  /*
   1. 即对问题得解进行找规律，通过规律得到最优解
   2. 也可以通过 暴力递归 -> 记忆搜索话 -> 动态规划 ，一步一步转移，基本结果无改变
  */
  ```

  

+ 暴力递归到动态规划(转化规程)

  ```java
  /*
   找到某个题得暴递归写法，分析其是否有重复解，如果有重复解则可以改动态规划，没有重复解则无法改动态规划。
   当对有重复解的递归该动态规划时，如果不讲究组织(则是记忆化搜索)，如果将其做精细化组织则是经典动态规划
   
   注意
   	暴力递归的时间复杂为O(n^2),动态规划(记忆化搜索)时间复杂度为O(n*logn) (但改为经典动态规划后可能还能进行优化，则时间复杂度将会更小一些)
   	暴力递归是列出所有结果然后求解，而动态规划是将每个结果规律化求解，两者可以相互转换，动态规划效率更高
  */
  ```
  
  
  
  



![image-20220328144620942](D:\typora_import_images\typora-user-images\image-20220328144620942.png)

![image-20220328140958701](D:\typora_import_images\typora-user-images\image-20220328140958701.png)

```java
/*
 每次递归实际上都是在做相同的事，只不过实际上会展开n个分支做这些事，此时可以得到n个结果
 暴力递归有大量重复的过程在浪费程序执行时间，把这些重复状态使用一个变量缓存此时就是动态规划( dp[] || dp[][])
 所有有规律(足够多的重复过程)的暴力递归都能改成动态规划(动态规划就是暴力递归转换过来的)
 递归转动态规划 可以画一张二维表 来分析思路(最终符合题意得为止就是该题得解)
*/
```

+ 打印一个字符串的全部序列

  ```java
  /*
   public class PrintArrayAllSort {
      public static void main(String[] args){
          List<String> abc = strSort("abc");
          for (String s : abc) {
              System.out.println();
          }
      }
      public static List<String> strSort(String str){
          List<String> list = new ArrayList<>();
          process(list,str.toCharArray(),0);
          return list; // [a,b,c] , [a,c,b]  [b,a,c]  [b,a,c]   [c,b,a]  [c,a,b]
      }
  
      public static void process(List<String> list,char[] c,int index){
          // 当index == c.length 的时候 说明此排列已经完成了
          if(index == c.length){
              System.out.println(c);
              list.add(c.toString());
              return;
          }
  
          for (int i = index; i < c.length; i++) {
              swap(c,i,index);
              process(list,c,index+1);
              swap(c,i,index);
          }
      }
      public static void swap(char[] c,int i, int j){
          char tmp = c[i];
          c[i] = c[j];
          c[j] = tmp;
      }
  }
  
  */
  ```

  ![image-20220327115527224](D:\typora_import_images\typora-user-images\image-20220327115527224.png)

  ![image-20220327120403566](D:\typora_import_images\typora-user-images\image-20220327120403566.png)

  

+ 从左往右尝试模型

  ```java
  /*
   即 从左往右思考问题，尝试得到问题的解
  */
  ```

  

  + 题目一![image-20220327151544710](D:\typora_import_images\typora-user-images\image-20220327151544710.png)

    ```java
    public class AssociateNumber {
        public static void main(String[] args) {
            System.out.println(process("8111".toCharArray(), 0));
        }
    
        /**
         * 当 输入一串0-9的字符串后，判断其能有多少种字母的排列组合
         * 如   111    有 aaa  ak ka  3 种
         *
         * @description: 此方法用来获取该问题的解
         * @description:  关于递归的返回值的补充
         *              递归可以返回任何类型，但不能直接把返回值整个返回会去,这样只能得到一个解，如果想得到多个解可以
         *              定义一个变量接收，算完所有解后再把该变量返回即可
         */
        public static int process(char[] c, int i) {
            if (i == c.length) { // 当一次方法全部组合完毕后，得到一个该问题的解
                return 1;
            }
            if (c[i] == '0') { // 当遇到0则得不到一个问题的解，因为被其阻拦
                return 0;
            }
            if (c[i] == '1') {
                int result = 0; // 处理 1 ~ 19
                result += process(c, i + 1);
                if(i+1<c.length){
                    result += process(c, i + 2);
                }
                return result;
            }
    
            if(c[i] == '2'){ // 处理 2~ 2n(n范围在 0~6)
                int res = 0;
                res += process(c, i + 1);
                if(i+1<c.length &&  c[i+1]>='0' && c[i+1]<='6'){
                    res+=process(c,i+2);
                }
                return res;
            }
            return process(c,i+1); // 3~9 的情况
        }
    }
    
     // 暴力递归改动态规划
        public static int dp(String s) {
            if (s == null || s.length() == 0) {
                return 0;
            }
            char[] str = s.toCharArray();
            int N = str.length;
            int[] dp = new int[N + 1];
            dp[N] = 1;
            for (int i = N - 1; i >= 0; i--) {
    
                if (str[i] == '0') {
                    dp[i] = 0;
                }else if (str[i] == '1') {
                    dp[i] = dp[i + 1];
                if (i + 1 < str.length) {
                dp[i] += dp[i + 2];
                    }
                }else if (str[i] == '2') {
                    dp[i] = dp[i + 1];
                    if (i + 1 < str.length && str[i + 1] >= '0' && str[i + 1] <= '6') {
                        dp[i] += dp[i + 2];
                    }
                }else{
                    dp[i] = dp[i+1];
                }
            }
            return dp[0];
        }
    ```
  
    
  
  + 题目二
  
    ![image-20220327161535043](D:\typora_import_images\typora-user-images\image-20220327161535043.png)
  
    ```java
    
     /**
         * @param v 货物的总价值
         * @param w 货物的总重量
         * @param alreadyW 已装货物的总重量
         * @param index 已装货物的个数
         * @param bagSize 背包的容量
         *                
         * @description: 当使用回溯法求解时，应把多把递归的解进行收集到一个变量种，然后返回 变量
         * */
        public static  int process(int[] w,int[] v,int index,int alreadyW,int bagSize){
            if(alreadyW > bagSize){ // 货物已经装不下
                return -1;
            }
            if(index == w.length){ // 货物装的下
                return 0;
            }
            int p1 = process(w,v,index+1,alreadyW,bagSize); // 保存背包初始容量
            int p2next = process(w,v,index+1,alreadyW+w[index],bagSize); // 保存 最新的背包容量
            int p2 = -1;
            if(p2next!=-1){  // 当前决策不为-1
                p2=v[index]+p2next; // 则获得决策的值
            }
            return Math.max(p1,p2); // 返回最大背包容量
        }
    
    /*
     暴力递归改动态规划
    */
     public static int dpWay(int[] w, int[] v, int bag) {
            int N = w.length;
            int[][] dp = new int[N + 1][bag + 1];
            for (int index = N - 1; index >= 0; index--) {
                for (int rest = 0; rest <= bag; rest++) {
                    int p1 = dp[index + 1][rest];
                    int p2 = -1;
                    if (rest - w[index] >= 0) {
                        p2 = v[index] + dp[index][rest - w[index]];
                    }
                    dp[index][rest] = Math.max(p1, p2);
    
                }
            }
            return dp[0][bag];
        }
    
    ```
  
    
  
    
  
  + 范围尝试的模型
  
    ![image-20220327165751464](D:\typora_import_images\typora-user-images\image-20220327165751464.png)
  
    
    
    + n皇后问题
    
      ![image-20220328134751914](D:\typora_import_images\typora-user-images\image-20220328134751914.png)
    
      ```java
      public class QueenQuestion {
          public static void main(String[] args) {
              int n = 8;
              int[] arr = new int[n];
              System.out.println(process(arr, 0, n));
          }
      
          /**
           * @param arr 存储数列得数组
           * @param i 为当前在第几行开始摆放皇后
           * @param n 为最后得行数
           * */
          public static int process(int[] arr, int i, int n) {
              if (i == n) { // 此时摆放成功了
                  System.out.println(Arrays.toString(arr));
                  return 1;
              }
              int res = 0;
              for (int j = 0; j < n; j++) {
                  if (isLegal(arr, i, j)) { // 每次判断该值是否合法
                      arr[i] = j;
                      res += process(arr, i + 1, n); //每成功摆放一组，返回结果到此行
                  }
              }
              return res; // 最终统计最后结果返回给调用者
          }
      
          /**
           * @param arr 已摆放位置得数组
           * @param i 当前准备摆放得行
           * @param j 当前准备方法行上得列位置
           * */
          public static boolean isLegal(int[] arr, int i, int j) {
              for (int k = 0; k < i; k++) {
                  if (arr[k] == j || Math.abs(i - k) == Math.abs(j - arr[k])) {
                      //  arr[k] == j 说明 在同一列
                      //  Math.abs(i - k) == Math.abs(j - arr[k]) 说明 在同一斜线
                      return false;
                  }
              }
              // 全部不冲突返回true
              return true;
          }
      
      }
      ```
    
      
    
    
  
  ![image-20220328140547790](D:\typora_import_images\typora-user-images\image-20220328140547790.png)
  
  
  
  



+ 动态规划——记忆化搜索

  ```java
  // 即在每次递归时使用一个变量(一维数组或者二维数组,变量名通常为dp)保存该值的结果，当再次递归时命中了该保存的值则直接返回缓存的结果而无需进行暴力递归
  ```

  

  ![image-20220328141053837](D:\typora_import_images\typora-user-images\image-20220328141053837.png)

  ```java
  // 暴力递归解法
  public class RobotWalk {
      public static void main(String[] args) {
          System.out.println(process(5,2,5,3));
      }
  
      /**
       * @param n    总共有的位置数
       * @param cur  当前在的位置
       * @param rest 剩余的步数
       * @param p    最总的目标位置
       * @return 返回全部能达到终点的方法
       */
      public static int process(int n, int cur, int rest, int p) {
          if (rest == 0) { // 当不能走时判断是否达到目标点
              return cur == p ? 1 : 0;
          }
          if (cur == 1) { // 当前来到首位置，此时只能往右走
              return process(n, cur + 1, rest - 1, p);
          }
          if (cur == n) {  // 当来到末尾位置，此时只能往左走
              return process(n, cur - 1, rest, p);
          }
  
          // 此时在中间位置可以往两边走，因此值可以累加
          return process(n, cur - 1, rest - 1, p) + process(n, cur + 1, rest - 1, p);
      }
  }
  
  // ========================================
  // 动态规划——记忆搜索化解法
    public static void main(String[] args) {
          int n = 5;
          int cur = 2;
          int rest = 5;
          int p = 3;
          // dp用于收集所有暴力递归不重复的结果  ,
          int[][] dp = new int[n + 1][rest + 1];
  
          // 将dp初始化
          for (int i = 0; i < dp.length; i++) {
              for (int j = 0; j < dp[i].length; j++) {
                  dp[i][j] = -1;
              }
          }
          System.out.println(process(n, cur, rest, p, dp));
      }
  
      /**
       * @param n    总共有的位置数
       * @param cur  当前在的位置
       * @param rest 剩余的步数
       * @param p    最总的目标位置
       * @param dp   每次值的缓存
       * @return 返回全部能达到终点的方法
       * @description: 动态规划——记忆搜索化解法
       */
      public static int process(int n, int cur, int rest, int p, int[][] dp) {
          if (dp[cur][rest] != -1) {
              return dp[cur][rest];
          }
  
          if (rest == 0) { // 当不能走时判断是否达到目标点
              dp[cur][rest] = cur == p ? 1 : 0;
              return dp[cur][rest];
          }
          if (cur == 1) { // 当前来到首位置，此时只能往右走
              dp[cur][rest] = process(n, cur + 1, rest - 1, p, dp);
              return dp[cur][rest];
          }
          if (cur == n) {  // 当来到末尾位置，此时只能往左走
              dp[cur][rest] = process(n, cur - 1, rest, p, dp);
              return dp[cur][rest];
          }
  
          // 此时在中间位置可以往两边走，因此值可以累加
          dp[cur][rest] = process(n, cur - 1, rest - 1, p, dp) + process(n, cur + 1, rest - 1, p, dp);
          return dp[cur][rest];
      }
  ```

  ![image-20220328155950371](D:\typora_import_images\typora-user-images\image-20220328155950371.png)





+ ![image-20220330101216023](D:\typora_import_images\typora-user-images\image-20220330101216023.png)

  

![image-20220330111626303](D:\typora_import_images\typora-user-images\image-20220330111626303.png)

![image-20220330111646367](D:\typora_import_images\typora-user-images\image-20220330111646367.png)

![image-20220330112015647](D:\typora_import_images\typora-user-images\image-20220330112015647.png)



+ ![image-20220330112120628](D:\typora_import_images\typora-user-images\image-20220330112120628.png)

  ```java
  ```

  ![image-20220330113833731](D:\typora_import_images\typora-user-images\image-20220330113833731.png)

  ```java
  /*
  	
  */
  ```

  



+ 找零问题(满足找零问题的前提下，使用的钱币最少(如 有1 5 10 20  50 100 面值的钱币，当找零为92时 使用 50 20 20 1 1 找零最少))

  ```java
  public class GiveChangeQuestion {
      public static void main(String[] args) {
          int[] arr = {1, 5, 10, 20, 50, 100};
          int index = 0;
          int rest = 200;
          System.out.println(process1(arr, index, rest));
          int len = arr.length;
          int[][] dp = new int[len + 1][rest + 1];
          for (int i = 0; i < dp.length; i++) {
              for (int j = 0; j < dp[0].length; j++) {
                  dp[i][j] = -1;
              }
          }
          System.out.println(process2(arr, index, rest, dp));
          System.out.println(process3(arr, rest));
      }
  
      /**
       * @param arr   arr中存放着所有面值的钱币
       * @param index 存储着面值的索引
       * @param rest  剩余需要找零的面值
       * @return 为找零的方式
       * @description: 此方法为暴力递归求解
       */
      public static int process1(int[] arr, int index, int rest) {
  
          // 当index == arr.length时 说明此面值选择已经完成了
          if (index == arr.length) {
              return rest == 0 ? 1 : 0;
          }
          int ways = 0;
          // 每次对应一个类型组合
          for (int i = 0; i * arr[index] <= rest; i++) {
              ways += process1(arr, index + 1, rest - (i * arr[index]));
          }
          return ways;
      }
  
      /**
       * @param arr   arr中存放着所有面值的钱币
       * @param index 存储着面值的索引
       * @param rest  剩余需要找零的面值
       * @param dp    缓存每个点位的数据，带递归再走到此位置时直接返回结果
       * @return 为找零的方式
       * @description: 此方法为动态规划-记忆线索化求解
       */
      public static int process2(int[] arr, int index, int rest, int[][] dp) {
  
          // 当index == arr.length时 说明此面值选择已经完成了
          if (dp[index][rest] != -1) { // 判断这个路线在本次递归是否走过，如果走过直接返回结果
              return dp[index][rest];
          }
          if (index == arr.length) {
              dp[rest][index] = rest == 0 ? 1 : 0; // 记录此路线的解
              return dp[index][rest];
          }
  
          int ways = 0;
          for (int i = 0; i * arr[index] <= rest; i++) {
              dp[index][rest] = process1(arr, index + 1, rest - (i * arr[index]));
              ways += dp[index][rest];
          }
          return ways;
      }
  
      /**
       * @param arr arr中存放着所有面值的钱币
       * @param aim 剩余需要找零的面值
       * @return 为找零的方式
       * @description: 此方法为经典动态规划 , 和记忆化搜索的时间复杂度相同 . 它是由暴力递归改写而来
       */
      public static int process3(int[] arr, int aim) {
          int N = arr.length;
          int[][] dp = new int[N + 1][aim + 1];
          dp[N][0] = 1;
  
          for (int index = N - 1; index >= 0; index--) {
              for (int rest = 0; rest <= aim; rest++) {
                  int ways = 0;
                  // 有枚举行为的动态规划可以进一步划分
                  for (int zhang = 0; zhang * arr[index] <= rest; zhang++) {
                      ways += dp[index + 1][rest - (zhang * arr[index])];
                  }
                  dp[index][rest] = ways;
              }
          }
          return dp[0][aim];
      }
  
      /**
       * @param arr arr中存放着所有面值的钱币
       * @param aim 剩余需要找零的面值
       * @return 为找零的方式
       * @description: 此方法为优化枚举版动态规划 ,
       */
      public static int process4(int[] arr, int aim) {
          int N = arr.length;
          int[][] dp = new int[N + 1][aim + 1];
          dp[N][0] = 1;
  
          for (int index = N - 1; index >= 0; index--) {
              for (int rest = 0; rest <= aim; rest++) {
  
                  dp[index][rest] = dp[index + 1][rest]; // 获得前一个货币
                  if (rest - arr[index] >= 0) { // 如果不越界 则  获得前二个货币
                      dp[index][rest] += dp[index][rest - arr[index]];
                  }
              }
          }
          return dp[0][aim];
      }
  
  }
  ```

  



### 2.4 动态规划

动态规划 三部曲：**初始状态，找规律->状态转移方程**







+ 引入

  ![image-20220304143546511](D:\typora_import_images\typora-user-images\image-20220304143546511.png)

  ![image-20220304143741380](D:\typora_import_images\typora-user-images\image-20220304143741380.png)

  ![image-20220304143820588](D:\typora_import_images\typora-user-images\image-20220304143820588.png)

  

  

  

  ![image-20220304150803410](D:\typora_import_images\typora-user-images\image-20220304150803410.png)

  
  
  

![image-20220306174226829](D:\typora_import_images\typora-user-images\image-20220306174226829.png)





### 2.5 KMP算法

+ 引入

  ![image-20220307092119361](D:\typora_import_images\typora-user-images\image-20220307092119361.png)

  ![image-20220307092216282](D:\typora_import_images\typora-user-images\image-20220307092216282.png)

  

  

+ 介绍

  ![image-20220307105449889](D:\typora_import_images\typora-user-images\image-20220307105449889.png)

  ![image-20220307105913318](D:\typora_import_images\typora-user-images\image-20220307105913318.png)

  ![image-20220307114028428](D:\typora_import_images\typora-user-images\image-20220307114028428.png)

  ![image-20220307114347618](D:\typora_import_images\typora-user-images\image-20220307114347618.png)

  

  ```java
  /*
   public class KMP {
      public static void main(String[] args) {
          System.out.println(violentSearch("ABBBAA ABC AA BB ABBBAA ABC AA BBABBBAA ABC AA BB" +
                  "AAA", "AAA"));
          // =================================================================================
          int[] next = getNext("AAA");
          System.out.println(kmpSearch("ABBBAA ABC AA BB ABBBAA ABC AA BBABBBAA ABC AA BB" +
                  "AAA", "AAA", next));
      }
  
      public static int kmpSearch(String s1, String s2, int[] next) {
          for (int i = 0, j = 0; i < s1.length(); i++) {
  
              // 使用kmp查找公式
              while (j > 0 && s1.charAt(i) != s2.charAt(j)) {
                  j = next[j - 1];
              }
  
              if (s1.charAt(i) == s2.charAt(j)) {
                  j++;
              }
              if (j == s2.length()) {
                  return i - j + 1;
              }
          }
  
          return -1;
      }
  
      public static int violentSearch(String s1, String s2) {
          int j = 0;
          for (int i = 0; i < s1.length(); i++) {
  
              // 如果相等代表匹配 ，此时 j++
              if (s1.charAt(i) == s2.charAt(j)) {
                  j++;
              } else { // 如果不等 则需要重新进行匹配 j 置为 0
                  j = 0;
              }
  
              // 如果连续几个字符都相等，且j等于查找字符串的长度，说明已经找到返回即可
              if (j == s2.length()) {
                  return i - j + 1;
              }
  
          }
          return -1;
      }
  
      public static int[] getNext(String str1) {
          int strLen = str1.length();
          int[] next = new int[strLen];
  
          // 第一个索引位置一定为0 因为其没有前缀和后缀
          next[0] = 0;
          for (int i = 1, j = 0; i < strLen; i++) {
  
              // 如果 j 位置的值和j位置的值不相等，则j获取next表中前一个位置的值，直到该位置的值相等或j为0时退出
              // kmp核心算法
              while (j > 0 && str1.charAt(i) != str1.charAt(j)) {
                  j = next[j - 1];
              }
  
              //  如果条件满足 就说明 有一个相同的值,即存在匹配值(前缀&后缀)
              if (str1.charAt(i) == str1.charAt(j)) {
                  j++;
              }
              next[i] = j; // 将j的值复制给i索引位置
          }
          return next;
  
      }
  }
  
  */
  ```

  

  

### 2.6 贪心算法

+ 引入

  ![image-20220307200551019](D:\typora_import_images\typora-user-images\image-20220307200551019.png)

  

  

+ 介绍

  ![image-20220307200655933](D:\typora_import_images\typora-user-images\image-20220307200655933.png)

  ![image-20220307201026021](D:\typora_import_images\typora-user-images\image-20220307201026021.png)

   

  

  

### 2.7 普利姆算法

+ 引入

  ![image-20220308100758099](D:\typora_import_images\typora-user-images\image-20220308100758099.png)

  ![image-20220308100859587](D:\typora_import_images\typora-user-images\image-20220308100859587.png)

  

  

  + 介绍

    ![image-20220308101129929](D:\typora_import_images\typora-user-images\image-20220308101129929.png)

    普利姆算法，会从该顶点的连接点开始找一个相邻的权值最小的邻边顶点进行连接，然后下次查找以该邻边为起始点，找离它权值最小的边(未被访问)，往复如此，直到所有连接点都被连接且权值最小

    ![image-20220308103539414](D:\typora_import_images\typora-user-images\image-20220308103539414.png)

    ```java
    /*
     public class PrimAlgorithm {
        public static void main(String[] args) {
            char[] data = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
            int vertexNUms = data.length;
            int[][] weight = {
                    {100, 5, 7, 100, 100, 100, 2},
                    {5, 100, 100, 9, 100, 100, 3},
                    {7, 100, 100, 100, 8, 100, 100},
                    {100, 9, 100, 100, 100, 4, 100},
                    {100, 100, 8, 100, 100, 5, 4},
                    {100, 100, 100, 4, 5, 100, 6},
                    {2, 3, 100, 100, 4, 5, 100},
            };
            MGraph mGraph = new MGraph(vertexNUms);
            MinTree minTree = new MinTree();
            minTree.createGraph(mGraph, vertexNUms, data, weight);
          //  minTree.showGraph(mGraph);
            minTree.prim(mGraph,0);
        }
    }
    
    class MinTree {
    
        // 创建一个图
        public void createGraph(MGraph graph, int vertexNums, char data[], int[][] weight) {
            for (int i = 0; i < vertexNums; i++) {
                graph.data[i] = data[i];
                for (int j = 0; j < vertexNums; j++) {
                    graph.weight[i][j] = weight[i][j];
                }
            }
    
        }
    
        // 显示图的连接矩阵
        public void showGraph(MGraph graph) {
            for (int[] ints : graph.weight) {
                System.out.println(Arrays.toString(ints));
            }
        }
    
        // 此方法每次会强制去找一个该连接点的最短路径顶点
        public void prim(MGraph graph, int v) {
    
            int visited[] = new int[graph.vertexNums]; // 用一个数组标记该路是否联通
            visited[v] = 1; // 将本次顶点进行标记
            int h1 = -1; // 保存本次顶点
            int h2 = -1; // 保存本顶点的路径最短的邻接顶点
            int minWeight = 100; // 用于当顶点间的隔离点
            for (int i = 1; i < graph.vertexNums; i++) { // 因为要找 n-1 次 路径所以1从 1开始循环
    
                for (int j = 0; j < graph.vertexNums; j++) { // 以第 1 个顶点开始查找
                    for (int k = 0; k < graph.vertexNums; k++) { // 找到该顶点的最短路径的邻接顶点
                        // 每次找一个联通的值，且这个值未被连接，同时再此次查找中是最短的一个路径顶点
                        if (visited[j] == 1 && visited[k] == 0
                                && graph.weight[j][k] < minWeight) {
                            minWeight = graph.weight[j][k];
                            h1 = j;
                            h2 = k;
                        }
                    }
                }
                System.out.println("边<" + graph.data[h1] + "," + graph.data[h2] +
                        "> 权值：" + minWeight);
                visited[h2] = 1; // 找到最短路径的邻接顶点，将其点置为 走过
                minWeight = 100; // 恢复初始值
            }
        }
    }
    
    class MGraph {
        int vertexNums;
        char[] data; // 存放节点数据
        int[][] weight; // 村方便
    
        // 初始化图
        public MGraph(int size) {
            vertexNums = size;
            data = new char[size];
            weight = new int[size][size];
        }
    
    
    }
    */
    ```

    

  

  

### 2.8 Kruskal算法

**Kruskal算法 称为 克鲁斯卡尔算法**,**普利姆算法和克鲁斯卡尔算法都是求最小生成树的算法**

+ 引入

  ![image-20220308115808706](D:\typora_import_images\typora-user-images\image-20220308115808706.png)

  

  

+ 介绍

  ![image-20220308120143291](D:\typora_import_images\typora-user-images\image-20220308120143291.png)

  

  
  
  



### 2.9 Dijkstra算法

**Dijkstra算法 又称 迪杰斯特拉算法**，该算法用于求解最短路径

+ 引入

  ![image-20220309111304603](D:\typora_import_images\typora-user-images\image-20220309111304603.png)

  

  

  

+ 介绍

  ![image-20220309111542922](D:\typora_import_images\typora-user-images\image-20220309111542922.png)

  ![image-20220309112108040](D:\typora_import_images\typora-user-images\image-20220309112108040.png)

  ![image-20220309113208838](D:\typora_import_images\typora-user-images\image-20220309113208838.png)

  





## 3.0 马踏棋盘

+ 介绍

  ![image-20220309152921334](D:\typora_import_images\typora-user-images\image-20220309152921334.png)

  ![image-20220309153810147](D:\typora_import_images\typora-user-images\image-20220309153810147.png)

  

+ 实现

  ```java
  /*
   public class HorseChessboard {
      private static int X; // 行
      private static int Y; // 列
      // 创建一个数组，标记期盼的各个位置是否被访问过
      private static boolean visited[];
      private static boolean finished;
  
      public static void main(String[] args) {
          long t1 = System.currentTimeMillis();
          start();
          long t2 = System.currentTimeMillis();
          System.out.println("消耗时间：" + (t2 - t1));
      }
  
      public static void start() {
          /**
           *  常规算法 非常消耗时间(1min左右)，因为其是常规算法，使用贪心算法可以提高效率
           * */
          // 测试
          X = 7;
          Y = 7;
          
          // 马开始的位置
          int row = 3;
          int col = 3;
          int[][] chessboard = new int[X][Y];
          visited = new boolean[X * Y];
  
          traversalChessboard(chessboard, row - 1, col - 1, 1);
  
          for (int[] ints : chessboard) {
              System.out.println(Arrays.toString(ints));
          }
      }
  
      /**
       * @param chessboard 棋盘
       * @param row        马的行位置
       * @param col        马的列位置
       * @param step       走的第几步
       */
      public static void traversalChessboard(int[][] chessboard, int row, int col, int step) {
          chessboard[row][col] = step;
          // row * X + col 为一个小算法， 可以定位到指定位置
          visited[row * X + col] = true; // 把当前位置标记为走过
          // 获得当前位置可以走的下一个位置的集合
          ArrayList<Point> ps = next(new Point(col, row));
  
          sort(ps); // 对ps进行排序，这样可以优先走选择多的步数
  
          while (!ps.isEmpty()) {
              Point p = ps.remove(0);
  
              // 如果这一步没有走过。则走
              if (!visited[p.y * X + p.x]) {
  
                  traversalChessboard(chessboard, p.y, p.x, step + 1);
              }
  
          }
  
          // 如果没走通，则棋盘重置，开始回溯
          if (step < X * Y && !finished) {
              chessboard[row][col] = 0;
              visited[row * X + col] = false;
          } else {
              finished = true;
          }
  
      }
  
      // 获得该马可以走的位置，并存入到集合中
      public static ArrayList<Point> next(Point curPoint) {
          // 创建一个ArrayList
          ArrayList<Point> ps = new ArrayList<>();
  
          Point p1 = new Point();
          // 假设此时马再中间。此时可以走8各位置
          if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y - 1) >= 0) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y - 2) >= 0) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y - 2) >= 0) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y - 1) >= 0) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x + 2) < X && (p1.y = curPoint.y + 1) < Y) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x + 1) < X && (p1.y = curPoint.y + 2) < Y) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x - 1) >= 0 && (p1.y = curPoint.y + 2) < Y) {
              ps.add(new Point(p1));
          }
          if ((p1.x = curPoint.x - 2) >= 0 && (p1.y = curPoint.y + 1) < Y) {
              ps.add(new Point(p1));
          }
          return ps;
      }
  
      // 使用贪心算法优化
      // 根据当前这异步的所有下一步的选择位置，进行非递减排序
      public static void sort(ArrayList<Point> ps) {
          ps.sort(new Comparator<Point>() {
              @Override
              public int compare(Point o1, Point o2) {
                  // 获取到o1的下一步的所有位置个数
                  int count1 = next(o1).size();
                  int count2 = next(o2).size();
                  if (count1 < count1) { // 返回 -1 表示 o2排在o1前面
                      return -1;
                  } else if (count1 == count2) { // 返回 0 表示 位置不变
                      return 0;
                  } else { // 返回1 表示 o1排再o2前面
                      return 1;
                  }
              }
          });
      }
  }
  */
  ```

  
